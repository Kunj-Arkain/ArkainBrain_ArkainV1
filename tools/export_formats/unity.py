"""
ARKAINBRAIN — Unity Export Package Generator (Phase 10)

Generates a full Unity-ready package with:
- ScriptableObject definitions for symbols, paytable, features
- Prefab scaffold YAML for reels, symbol grid, UI
- Binary reel strip data as .asset files
- Sprite atlas metadata (compatible with Unity SpriteAtlas)
- Assembly definition for clean project structure
- README with integration guide
"""

import json
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Optional


# ─── ScriptableObject Templates ───

SYMBOL_SO = '''%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {{fileID: 0}}
  m_PrefabInstance: {{fileID: 0}}
  m_PrefabAsset: {{fileID: 0}}
  m_GameObject: {{fileID: 0}}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {{fileID: 11500000, guid: SCRIPT_GUID_PLACEHOLDER, type: 3}}
  m_Name: {name}
  m_EditorClassIdentifier:
  symbolName: {name}
  symbolType: {sym_type}
  payouts:
{payout_yaml}
  spritePath: Sprites/Symbols/{slug}
  hasAnimation: 1
  animationFrames: 8
  winAnimationFrames: 12
'''

GAME_CONFIG_SO = '''%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {{fileID: 0}}
  m_PrefabInstance: {{fileID: 0}}
  m_PrefabAsset: {{fileID: 0}}
  m_GameObject: {{fileID: 0}}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {{fileID: 11500000, guid: CONFIG_GUID_PLACEHOLDER, type: 3}}
  m_Name: GameConfig
  m_EditorClassIdentifier:
  gameTitle: {title}
  gridCols: {cols}
  gridRows: {rows}
  waysOrLines: {ways}
  targetRtp: {rtp}
  maxWinMultiplier: {max_win}
  volatility: {vol}
  reelCount: {cols}
  symbolCount: {sym_count}
'''

SYMBOL_SO_CS = '''// Auto-generated by ARKAINBRAIN Phase 10 Export
using UnityEngine;
using System;

[CreateAssetMenu(fileName = "NewSymbol", menuName = "SlotGame/Symbol Data")]
public class SymbolData : ScriptableObject
{{
    public string symbolName;
    public SymbolType symbolType;
    public int[] payouts;  // Index = count-1, value = payout multiplier
    public string spritePath;
    public bool hasAnimation;
    public int animationFrames;
    public int winAnimationFrames;
    public Sprite idleSprite;
    public Sprite[] winAnimation;
    public Sprite[] anticipationAnimation;
}}

public enum SymbolType {{ High, Medium, Low, Wild, Scatter, Bonus }}
'''

GAME_CONFIG_CS = '''// Auto-generated by ARKAINBRAIN Phase 10 Export
using UnityEngine;
using System;

[CreateAssetMenu(fileName = "GameConfig", menuName = "SlotGame/Game Config")]
public class GameConfig : ScriptableObject
{{
    [Header("Grid")]
    public int gridCols = {cols};
    public int gridRows = {rows};
    public int waysOrLines = {ways};

    [Header("Math")]
    public float targetRtp = {rtp}f;
    public float maxWinMultiplier = {max_win}f;
    public string volatility = "{vol}";

    [Header("Symbols")]
    public SymbolData[] symbols;

    [Header("Reels")]
    public TextAsset reelStripData;  // Binary reel strip asset

    [Header("Features")]
    public FeatureConfig[] features;
}}

[Serializable]
public class FeatureConfig
{{
    public string featureName;
    public string featureType;
    public float triggerProbability;
    public int freeSpinsAwarded;
    public float multiplier;
    public string description;
}}
'''

SPIN_CONTROLLER_CS = '''// Auto-generated by ARKAINBRAIN Phase 10 Export
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class SpinController : MonoBehaviour
{{
    [SerializeField] private GameConfig config;
    [SerializeField] private ReelStrip[] reels;
    [SerializeField] private float spinDuration = 1.5f;
    [SerializeField] private float reelStopDelay = 0.2f;

    private bool isSpinning = false;

    public void Spin()
    {{
        if (isSpinning) return;
        StartCoroutine(SpinSequence());
    }}

    private IEnumerator SpinSequence()
    {{
        isSpinning = true;

        // Start all reels spinning
        for (int i = 0; i < config.gridCols; i++)
        {{
            reels[i].StartSpin();
        }}

        yield return new WaitForSeconds(spinDuration);

        // Stop reels sequentially
        for (int i = 0; i < config.gridCols; i++)
        {{
            reels[i].StopSpin();
            yield return new WaitForSeconds(reelStopDelay);
        }}

        // Evaluate wins
        EvaluateResult();
        isSpinning = false;
    }}

    private void EvaluateResult()
    {{
        // TODO: Implement win evaluation using config.symbols payouts
        // This is a scaffold — connect to your game server for real results
        Debug.Log("Spin complete — evaluate wins against server response");
    }}
}}
'''

ASMDEF = '''{
    "name": "SlotGame.Generated",
    "rootNamespace": "SlotGame",
    "references": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}'''


def generate_unity_package(output_dir: str, game_title: str, config: dict,
                           symbols: list, reels: list, features: list,
                           sim_data: dict = None, **kwargs) -> str:
    """Generate enhanced Unity export package."""
    od = Path(output_dir)
    export_dir = od / "09_export"
    export_dir.mkdir(parents=True, exist_ok=True)

    slug = game_title.lower().replace(" ", "_").replace("'", "")[:30]
    zip_path = export_dir / f"{slug}_unity_v2.zip"

    cols = config.get("grid_cols", 5)
    rows = config.get("grid_rows", 3)
    ways = config.get("ways_or_lines", 243)
    rtp = config.get("target_rtp", 96.0)
    max_win = config.get("max_win_multiplier", 5000)
    vol = config.get("volatility", "medium")

    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
        pfx = f"{slug}_unity"

        # ── Assembly Definition ──
        zf.writestr(f"{pfx}/Scripts/SlotGame.Generated.asmdef", ASMDEF)

        # ── ScriptableObject C# Scripts ──
        zf.writestr(f"{pfx}/Scripts/Data/SymbolData.cs", SYMBOL_SO_CS)
        zf.writestr(f"{pfx}/Scripts/Data/GameConfig.cs",
                     GAME_CONFIG_CS.format(cols=cols, rows=rows, ways=ways,
                                           rtp=rtp, max_win=max_win, vol=vol))
        zf.writestr(f"{pfx}/Scripts/SpinController.cs", SPIN_CONTROLLER_CS)

        # ── ScriptableObject Assets (.asset YAML) ──
        # Game config SO
        zf.writestr(f"{pfx}/Resources/Data/GameConfig.asset",
                     GAME_CONFIG_SO.format(title=game_title, cols=cols, rows=rows,
                                           ways=ways, rtp=rtp, max_win=max_win,
                                           vol=vol, sym_count=len(symbols)))

        # Symbol SOs
        for sym in symbols:
            name = sym.get("name", "Unknown")
            slug_s = name.lower().replace(" ", "_")
            sym_type = _guess_symbol_type(name)
            pays = sym.get("payouts", [])
            if not pays:
                pays = [sym.get(f"{i}_of_a_kind", sym.get(f"{i}oak", 0)) for i in range(2, 7)]
            payout_yaml = "\n".join(f"  - {p}" for p in pays) if pays else "  - 0"

            zf.writestr(f"{pfx}/Resources/Data/Symbols/{slug_s}.asset",
                         SYMBOL_SO.format(name=name, sym_type=sym_type,
                                          slug=slug_s, payout_yaml=payout_yaml))

        # ── JSON Data ──
        zf.writestr(f"{pfx}/Resources/Data/config.json", json.dumps(config, indent=2))
        zf.writestr(f"{pfx}/Resources/Data/paytable.json", json.dumps(symbols, indent=2))
        zf.writestr(f"{pfx}/Resources/Data/reelstrips.json", json.dumps(reels, indent=2))
        zf.writestr(f"{pfx}/Resources/Data/features.json", json.dumps(features, indent=2))

        if sim_data:
            zf.writestr(f"{pfx}/Resources/Data/simulation.json", json.dumps(sim_data, indent=2))

        # ── Binary reel data (.bytes for Unity TextAsset) ──
        reel_binary = _encode_reels_binary(reels)
        zf.writestr(f"{pfx}/Resources/Data/reelstrips.bytes", reel_binary)

        # ── Sprite placeholders ──
        for sym in symbols:
            slug_s = sym.get("name", "sym").lower().replace(" ", "_")
            zf.writestr(f"{pfx}/Sprites/Symbols/{slug_s}/.gitkeep", "")

        # ── Copy existing art assets if available ──
        art_dir = od / "04_art"
        if art_dir.exists():
            for img in art_dir.rglob("*"):
                if img.is_file() and img.suffix.lower() in (".png", ".jpg", ".jpeg", ".webp"):
                    zf.write(img, f"{pfx}/Sprites/{img.relative_to(art_dir)}")

        # ── README ──
        zf.writestr(f"{pfx}/README.md", _unity_readme(game_title, config, symbols, features))

    return str(zip_path)


def _guess_symbol_type(name: str) -> str:
    n = name.lower()
    if "wild" in n: return "Wild"
    if "scatter" in n: return "Scatter"
    if "bonus" in n: return "Bonus"
    if n.startswith("h") or any(c in n for c in ["king", "queen", "pharaoh", "dragon"]): return "High"
    if n.startswith("l") or any(c in n for c in ["a", "k", "q", "j", "10", "9"]): return "Low"
    return "Medium"


def _encode_reels_binary(reels: list) -> bytes:
    """Encode reel strips as binary: [num_reels][reel_lengths...][reel_data...]"""
    import struct
    buf = bytearray()
    buf += struct.pack("<I", len(reels))
    for reel in reels:
        if isinstance(reel, list):
            buf += struct.pack("<I", len(reel))
    for reel in reels:
        if isinstance(reel, list):
            for sym in reel:
                if isinstance(sym, str):
                    buf += struct.pack("<B", hash(sym) % 256)
                elif isinstance(sym, (int, float)):
                    buf += struct.pack("<B", int(sym) % 256)
    return bytes(buf)


def _unity_readme(title, config, symbols, features):
    return f"""# {title} — Unity Export Package
Generated by ARKAINBRAIN Pipeline v10 on {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Quick Start
1. Import this folder into your Unity project's `Assets/` directory
2. The `GameConfig` ScriptableObject in `Resources/Data/` contains all game parameters
3. Each symbol has its own `SymbolData` ScriptableObject in `Resources/Data/Symbols/`
4. Attach `SpinController.cs` to your main game object
5. Wire up the GameConfig reference and reel strip references

## Structure
```
Scripts/
  Data/SymbolData.cs          — ScriptableObject definition for symbols
  Data/GameConfig.cs          — ScriptableObject for game configuration
  SpinController.cs           — Basic spin controller scaffold
Resources/Data/
  GameConfig.asset            — Pre-configured game settings
  Symbols/*.asset             — {len(symbols)} symbol ScriptableObjects
  config.json                 — Raw JSON config
  paytable.json               — Full paytable data
  reelstrips.json             — Reel strip definitions
  reelstrips.bytes            — Binary reel data for TextAsset loading
  features.json               — Feature configurations
Sprites/                      — Symbol sprite placeholders (add your art here)
```

## Configuration
- Grid: {config.get('grid_cols')}×{config.get('grid_rows')}
- Ways/Lines: {config.get('ways_or_lines')}
- Target RTP: {config.get('target_rtp')}%
- Max Win: {config.get('max_win_multiplier')}x
- Volatility: {config.get('volatility')}
- Symbols: {len(symbols)}
- Features: {len(features)}

## Important
This is a CLIENT-SIDE scaffold. All game outcomes must come from a certified RNG server.
The spin controller is a UI framework — connect it to your Game Server API for real results.
"""
