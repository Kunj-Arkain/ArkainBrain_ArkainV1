<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>ARCADE Engine â€” Test</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:#030014;color:#e2e8f0;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px}
#gc{width:100%;max-width:500px;aspect-ratio:4/3;background:rgba(99,102,241,0.05);border-radius:12px;border:1px solid rgba(99,102,241,0.15);overflow:hidden;cursor:pointer;position:relative}
#status{margin-top:16px;font-size:13px;color:#94a3b8}
#fps{margin-top:8px;font-size:11px;color:#64748b;font-family:monospace}
.hint{margin-top:12px;font-size:11px;color:#475569}
</style>
</head>
<body>
<div id="gc"></div>
<div id="status">Loading engine...</div>
<div id="fps">â€”</div>
<div class="hint">Click the canvas to trigger explosions</div>
<script>
// ARCADE Engine v4 â€” Bundled


// â”€â”€â”€â”€ engine/core.js (149 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Core Game Loop & State Machine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const GameState = {
  IDLE: 'idle',
  BETTING: 'betting',
  PLAYING: 'playing',
  RESOLVING: 'resolving',
  RESULT: 'result',
  ANIMATING: 'animating',
};

class GameLoop {
  constructor() {
    this.running = false;
    this.paused = false;
    this.rafId = null;
    this.lastTime = 0;
    this.accumulator = 0;
    this.fixedDT = 1000 / 60;
    this.maxAccumulator = 200;
    this.timeScale = 1.0;
    this.frame = 0;
    this.elapsed = 0;           // total elapsed seconds
    this.fps = 60;
    this.fpsSmooth = 60;
    this._fpsBuf = new Float32Array(60);
    this._fpsIdx = 0;
    this._fpsFill = 0;
    this.perfTier = 'high';     // high | medium | low
    this._degradeCount = 0;

    this.state = GameState.IDLE;
    this.stateData = {};
    this._stateListeners = {};
    this.systems = [];

    this._boundTick = this._tick.bind(this);
    this._boundVis = this._onVis.bind(this);
    document.addEventListener('visibilitychange', this._boundVis);
  }

  addSystem(sys) { this.systems.push(sys); return this; }
  removeSystem(sys) { const i = this.systems.indexOf(sys); if (i >= 0) this.systems.splice(i, 1); }

  setState(s, data = {}) {
    const prev = this.state;
    if (prev === s) return;
    this.state = s;
    this.stateData = data;
    (this._stateListeners[s] || []).forEach(fn => fn(data, prev));
  }

  onState(s, fn) {
    (this._stateListeners[s] || (this._stateListeners[s] = [])).push(fn);
    return this;
  }

  start() {
    if (this.running) return;
    this.running = true;
    this.lastTime = performance.now();
    this.accumulator = 0;
    this.rafId = requestAnimationFrame(this._boundTick);
  }

  stop() {
    this.running = false;
    if (this.rafId) { cancelAnimationFrame(this.rafId); this.rafId = null; }
  }

  _tick(now) {
    if (!this.running) return;
    this.rafId = requestAnimationFrame(this._boundTick);
    if (this.paused) return;

    let rawDT = now - this.lastTime;
    this.lastTime = now;
    if (rawDT > this.maxAccumulator) rawDT = this.fixedDT;

    // FPS
    const instantFPS = rawDT > 0 ? 1000 / rawDT : 60;
    this._fpsBuf[this._fpsIdx] = instantFPS;
    this._fpsIdx = (this._fpsIdx + 1) % 60;
    this._fpsFill = Math.min(this._fpsFill + 1, 60);
    let sum = 0;
    for (let i = 0; i < this._fpsFill; i++) sum += this._fpsBuf[i];
    this.fps = instantFPS;
    this.fpsSmooth = sum / this._fpsFill;

    // Auto-degrade
    if (this.fpsSmooth < 35) {
      if (++this._degradeCount > 90) {
        if (this.perfTier === 'high') this.perfTier = 'medium';
        else if (this.perfTier === 'medium') this.perfTier = 'low';
        this._degradeCount = 0;
      }
    } else {
      this._degradeCount = Math.max(0, this._degradeCount - 2);
    }

    const scaled = rawDT * this.timeScale;
    this.accumulator += scaled;
    const step = this.fixedDT * this.timeScale;
    const dtSec = step / 1000;

    let steps = 0;
    while (this.accumulator >= step && steps < 5) {
      for (const sys of this.systems) if (sys.update) sys.update(dtSec, this);
      this.accumulator -= step;
      this.elapsed += dtSec;
      steps++;
    }

    const alpha = this.accumulator / step;
    for (const sys of this.systems) if (sys.render) sys.render(alpha, this);
    this.frame++;
  }

  _onVis() {
    if (document.hidden) {
      this.paused = true;
    } else {
      this.paused = false;
      this.lastTime = performance.now();
      this.accumulator = 0;
    }
  }

  setTimeScale(target, duration = 0) {
    if (duration <= 0) { this.timeScale = target; return; }
    const from = this.timeScale;
    const t0 = performance.now();
    const step = () => {
      const p = Math.min((performance.now() - t0) / duration, 1);
      this.timeScale = from + (target - from) * p * p;  // ease-in
      if (p < 1) requestAnimationFrame(step);
    };
    step();
  }

  destroy() {
    this.stop();
    document.removeEventListener('visibilitychange', this._boundVis);
    this.systems.length = 0;
    this._stateListeners = {};
  }
}


// â”€â”€â”€â”€ engine/easing.js (178 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Easing Functions & Spring Physics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Ease = {
  // Linear
  linear: t => t,

  // Quad
  inQuad: t => t * t,
  outQuad: t => t * (2 - t),
  inOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,

  // Cubic
  inCubic: t => t * t * t,
  outCubic: t => (--t) * t * t + 1,
  inOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,

  // Quart
  inQuart: t => t * t * t * t,
  outQuart: t => 1 - (--t) * t * t * t,
  inOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,

  // Quint
  inQuint: t => t * t * t * t * t,
  outQuint: t => 1 + (--t) * t * t * t * t,
  inOutQuint: t => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t,

  // Sine
  inSine: t => 1 - Math.cos(t * Math.PI / 2),
  outSine: t => Math.sin(t * Math.PI / 2),
  inOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,

  // Expo
  inExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  outExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  inOutExpo: t => {
    if (t === 0 || t === 1) return t;
    return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  },

  // Circ
  inCirc: t => 1 - Math.sqrt(1 - t * t),
  outCirc: t => Math.sqrt(1 - (--t) * t),
  inOutCirc: t => t < 0.5 ? (1 - Math.sqrt(1 - 4 * t * t)) / 2 : (Math.sqrt(1 - (-2 * t + 2) * (-2 * t + 2)) + 1) / 2,

  // Back (overshoot)
  inBack: t => { const s = 1.70158; return t * t * ((s + 1) * t - s); },
  outBack: t => { const s = 1.70158; return (t -= 1) * t * ((s + 1) * t + s) + 1; },
  inOutBack: t => {
    const s = 1.70158 * 1.525;
    if (t < 0.5) return (2 * t) * (2 * t) * ((s + 1) * 2 * t - s) / 2;
    return ((2 * t - 2) * (2 * t - 2) * ((s + 1) * (2 * t - 2) + s) + 2) / 2;
  },

  // Elastic
  inElastic: t => {
    if (t === 0 || t === 1) return t;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * (2 * Math.PI / 3));
  },
  outElastic: t => {
    if (t === 0 || t === 1) return t;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI / 3)) + 1;
  },
  inOutElastic: t => {
    if (t === 0 || t === 1) return t;
    const s = (2 * Math.PI) / 4.5;
    if (t < 0.5) return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * s)) / 2;
    return (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * s)) / 2 + 1;
  },

  // Bounce
  outBounce: t => {
    const n1 = 7.5625, d1 = 2.75;
    if (t < 1 / d1) return n1 * t * t;
    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  },
  inBounce: t => 1 - Ease.outBounce(1 - t),
  inOutBounce: t => t < 0.5 ? (1 - Ease.outBounce(1 - 2 * t)) / 2 : (1 + Ease.outBounce(2 * t - 1)) / 2,

  // Custom: hard stop (for discrete steps)
  step: t => t < 1 ? 0 : 1,

  // Custom: smooth step
  smoothStep: t => t * t * (3 - 2 * t),
  smootherStep: t => t * t * t * (t * (t * 6 - 15) + 10),
};

/** Resolve easing by name string or function */
function resolveEase(e) {
  if (typeof e === 'function') return e;
  return Ease[e] || Ease.outCubic;
}


// â”€â”€ Spring Physics Solver â”€â”€
// Critically damped / underdamped spring for natural "juicy" motion

class Spring {
  constructor(opts = {}) {
    this.value = opts.from ?? 0;
    this.target = opts.to ?? 1;
    this.velocity = opts.velocity ?? 0;
    this.stiffness = opts.stiffness ?? 180;    // spring constant k
    this.damping = opts.damping ?? 12;         // damping coefficient c
    this.mass = opts.mass ?? 1;
    this.restThreshold = opts.restThreshold ?? 0.001;
    this.onUpdate = opts.onUpdate || null;
    this.onRest = opts.onRest || null;
    this.atRest = false;
  }

  /** Advance spring by dt seconds. Returns current value. */
  step(dt) {
    if (this.atRest) return this.value;

    // Clamp dt to prevent instability
    dt = Math.min(dt, 0.064);

    const displacement = this.value - this.target;
    const springForce = -this.stiffness * displacement;
    const dampingForce = -this.damping * this.velocity;
    const acceleration = (springForce + dampingForce) / this.mass;

    this.velocity += acceleration * dt;
    this.value += this.velocity * dt;

    // Check if at rest
    if (Math.abs(this.velocity) < this.restThreshold &&
        Math.abs(this.value - this.target) < this.restThreshold) {
      this.value = this.target;
      this.velocity = 0;
      this.atRest = true;
      if (this.onRest) this.onRest(this.value);
    }

    if (this.onUpdate) this.onUpdate(this.value, this.velocity);
    return this.value;
  }

  /** Snap to new target with optional impulse velocity */
  setTarget(target, impulse = 0) {
    this.target = target;
    this.velocity += impulse;
    this.atRest = false;
  }

  /** Reset to a value instantly */
  reset(val) {
    this.value = val;
    this.target = val;
    this.velocity = 0;
    this.atRest = true;
  }
}


// â”€â”€ Spring-animated property helper â”€â”€
// Usage: const s = springProp(obj, 'scale', { stiffness: 200, damping: 14 });
//        s.to(1.3);  // bouncy scale to 1.3

function springProp(obj, prop, opts = {}) {
  const spring = new Spring({
    from: obj[prop] ?? 0,
    to: obj[prop] ?? 0,
    ...opts,
    onUpdate: (v) => { obj[prop] = v; },
  });
  return {
    spring,
    to(val, impulse = 0) { spring.setTarget(val, impulse); },
    step(dt) { return spring.step(dt); },
    get value() { return spring.value; },
    get atRest() { return spring.atRest; },
  };
}


// â”€â”€â”€â”€ engine/tween.js (276 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Tween & Timeline Animation System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Tween {
  constructor(target) {
    this.target = target;
    this._queue = [];       // array of { props, duration, ease, delay, onUpdate, onComplete }
    this._current = null;
    this._elapsed = 0;
    this._startVals = {};
    this._dead = false;
    this._loop = false;
    this._yoyo = false;
    this._yoyoDir = 1;
  }

  /** Queue a tween step: tween(obj).to({ x: 100, alpha: 0 }, 600, 'outElastic') */
  to(props, duration = 300, ease = 'outCubic') {
    this._queue.push({ props, duration, ease: resolveEase(ease), delay: 0, onUpdate: null, onComplete: null });
    return this;
  }

  /** Wait before next step */
  wait(ms) {
    this._queue.push({ props: {}, duration: ms, ease: Ease.linear, delay: 0, onUpdate: null, onComplete: null, isWait: true });
    return this;
  }

  /** Delay before starting the next step */
  delay(ms) {
    if (this._queue.length > 0) {
      this._queue[this._queue.length - 1].delay = ms;
    }
    return this;
  }

  /** Callback during animation */
  onUpdate(fn) {
    if (this._queue.length > 0) this._queue[this._queue.length - 1].onUpdate = fn;
    return this;
  }

  /** Callback when step completes */
  onComplete(fn) {
    if (this._queue.length > 0) this._queue[this._queue.length - 1].onComplete = fn;
    return this;
  }

  /** Loop the entire sequence */
  loop(yoyo = false) {
    this._loop = true;
    this._yoyo = yoyo;
    return this;
  }

  /** Kill this tween */
  kill() { this._dead = true; }

  /** Advance by dt (seconds). Returns true if still alive. */
  update(dt) {
    if (this._dead) return false;
    const dtMs = dt * 1000;

    if (!this._current) {
      if (this._queue.length === 0) {
        if (this._loop) {
          // Restart queue â€” not implemented for simplicity, just die
          this._dead = true;
          return false;
        }
        this._dead = true;
        return false;
      }
      this._current = this._queue.shift();
      this._elapsed = -this._current.delay; // negative = in delay
      this._startVals = {};

      if (!this._current.isWait) {
        for (const key in this._current.props) {
          this._startVals[key] = this._readProp(key);
        }
      }
    }

    this._elapsed += dtMs;

    if (this._elapsed < 0) return true; // still in delay

    const c = this._current;
    const t = Math.min(this._elapsed / c.duration, 1);
    const easedT = c.ease(t);

    if (!c.isWait) {
      for (const key in c.props) {
        const from = this._startVals[key];
        const to = c.props[key];

        if (typeof from === 'number' && typeof to === 'number') {
          this._writeProp(key, from + (to - from) * easedT);
        } else if (typeof from === 'string' && from.startsWith('#')) {
          // Color interpolation
          this._writeProp(key, lerpColor(from, to, easedT));
        }
      }
    }

    if (c.onUpdate) c.onUpdate(easedT, this.target);

    if (t >= 1) {
      if (c.onComplete) c.onComplete(this.target);
      this._current = null;
      this._elapsed = 0;
    }

    return true;
  }

  _readProp(key) {
    // Support nested: 'pos.x'
    const parts = key.split('.');
    let obj = this.target;
    for (let i = 0; i < parts.length; i++) obj = obj[parts[i]];
    return obj;
  }

  _writeProp(key, val) {
    const parts = key.split('.');
    let obj = this.target;
    for (let i = 0; i < parts.length - 1; i++) obj = obj[parts[i]];
    obj[parts[parts.length - 1]] = val;
  }
}

/** Create a tween on target */
function tween(target) {
  const tw = new Tween(target);
  TweenManager.add(tw);
  return tw;
}


// â”€â”€ Tween Manager (system that plugs into GameLoop) â”€â”€

const TweenManager = {
  _tweens: [],

  add(tw) { this._tweens.push(tw); },

  update(dt) {
    for (let i = this._tweens.length - 1; i >= 0; i--) {
      if (!this._tweens[i].update(dt)) {
        this._tweens.splice(i, 1);
      }
    }
  },

  killAll() { this._tweens.forEach(t => t.kill()); this._tweens.length = 0; },

  /** Kill all tweens on a specific target */
  killTarget(target) {
    for (const tw of this._tweens) {
      if (tw.target === target) tw.kill();
    }
  },

  get count() { return this._tweens.length; },
};


// â”€â”€ Color Utilities â”€â”€

function hexToRGB(hex) {
  hex = hex.replace('#', '');
  if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16),
  };
}

function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(v => Math.round(Math.max(0, Math.min(255, v))).toString(16).padStart(2, '0')).join('');
}

function lerpColor(from, to, t) {
  const a = hexToRGB(from);
  const b = hexToRGB(to);
  return rgbToHex(
    a.r + (b.r - a.r) * t,
    a.g + (b.g - a.g) * t,
    a.b + (b.b - a.b) * t,
  );
}

function hexToRGBA(hex, alpha = 1) {
  const { r, g, b } = hexToRGB(hex);
  return `rgba(${r},${g},${b},${alpha})`;
}


// â”€â”€ Timeline: orchestrate multiple tweens â”€â”€

class Timeline {
  constructor() {
    this._entries = []; // { tween, startTime }
    this._time = 0;
    this._cursor = 0;   // current insert position in ms
    this._playing = false;
    this.onComplete = null;
  }

  /** Add a tween at the current cursor position */
  add(target, props, duration = 300, ease = 'outCubic') {
    const tw = new Tween(target);
    tw.to(props, duration, ease);
    this._entries.push({ tween: tw, startTime: this._cursor, started: false });
    return this;
  }

  /** Move cursor forward (for sequential animations) */
  then(offsetMs = 0) {
    // Find the latest end time
    let maxEnd = 0;
    for (const e of this._entries) {
      const dur = e.tween._queue.reduce((s, q) => s + q.duration + q.delay, 0);
      maxEnd = Math.max(maxEnd, e.startTime + dur);
    }
    this._cursor = maxEnd + offsetMs;
    return this;
  }

  /** Stagger: add multiple tweens with delay between each */
  stagger(targets, props, duration, ease, staggerMs) {
    for (let i = 0; i < targets.length; i++) {
      const tw = new Tween(targets[i]);
      tw.to(props, duration, ease);
      this._entries.push({ tween: tw, startTime: this._cursor + i * staggerMs, started: false });
    }
    return this;
  }

  play() {
    this._playing = true;
    this._time = 0;
    this._entries.forEach(e => { e.started = false; });
    TweenManager.add({ update: (dt) => this._update(dt), kill: () => { this._playing = false; }, _dead: false });
    return this;
  }

  _update(dt) {
    if (!this._playing) return false;
    this._time += dt * 1000;

    let allDone = true;
    for (const entry of this._entries) {
      if (this._time >= entry.startTime) {
        if (!entry.started) {
          entry.started = true;
          TweenManager.add(entry.tween);
        }
        if (!entry.tween._dead) allDone = false;
      } else {
        allDone = false;
      }
    }

    if (allDone) {
      this._playing = false;
      if (this.onComplete) this.onComplete();
      return false;
    }
    return true;
  }
}


// â”€â”€â”€â”€ engine/renderer.js (260 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Canvas Renderer (Dual-Layer + Sprite Cache)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Renderer {
  constructor(container, opts = {}) {
    this.container = typeof container === 'string' ? document.getElementById(container) : container;
    this.dpr = Math.min(window.devicePixelRatio || 1, opts.maxDPR || 2);
    this.width = 0;
    this.height = 0;

    // Create dual-layer canvases
    this.bgCanvas = this._createCanvas('arcade-bg', 1);
    this.fgCanvas = this._createCanvas('arcade-fg', 2);
    this.bgCtx = this.bgCanvas.getContext('2d');
    this.fgCtx = this.fgCanvas.getContext('2d');

    // Offscreen buffer for post-processing
    this._offscreen = document.createElement('canvas');
    this._offCtx = this._offscreen.getContext('2d');

    // Sprite cache (emoji / text â†’ bitmap)
    this._spriteCache = new Map();
    this._maxCacheSize = 100;

    // Post-processing stack
    this._postFX = [];

    // 3D perspective settings
    this.perspective = opts.perspective || 0;    // 0 = disabled
    this.tiltX = 0;
    this.tiltY = 0;

    // Resize
    this._resizeObserver = new ResizeObserver(() => this.resize());
    this._resizeObserver.observe(this.container);
    this.resize();
  }

  _createCanvas(id, zIndex) {
    const c = document.createElement('canvas');
    c.id = id;
    c.style.cssText = `position:absolute;inset:0;width:100%;height:100%;z-index:${zIndex};`;
    this.container.appendChild(c);
    return c;
  }

  resize() {
    const rect = this.container.getBoundingClientRect();
    this.width = rect.width;
    this.height = rect.height;
    const w = Math.round(rect.width * this.dpr);
    const h = Math.round(rect.height * this.dpr);

    for (const c of [this.bgCanvas, this.fgCanvas, this._offscreen]) {
      c.width = w;
      c.height = h;
    }

    // Scale contexts for DPR
    this.bgCtx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
    this.fgCtx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
    this._offCtx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

    // Apply 3D perspective if enabled
    if (this.perspective > 0) {
      this.container.style.perspective = this.perspective + 'px';
      this.container.style.perspectiveOrigin = '50% 50%';
    }
  }

  /** Clear foreground (call every frame) */
  clear() {
    this.fgCtx.clearRect(0, 0, this.width, this.height);
  }

  /** Clear background (call on init or theme change) */
  clearBG() {
    this.bgCtx.clearRect(0, 0, this.width, this.height);
  }

  /** Get sprite bitmap from cache (or render it) */
  getSprite(text, size = 32, color = null) {
    const key = `${text}_${size}_${color}`;
    if (this._spriteCache.has(key)) return this._spriteCache.get(key);

    // Evict oldest if cache full
    if (this._spriteCache.size >= this._maxCacheSize) {
      const firstKey = this._spriteCache.keys().next().value;
      this._spriteCache.delete(firstKey);
    }

    const padding = 4;
    const canvasSize = size + padding * 2;
    const offC = document.createElement('canvas');
    offC.width = canvasSize * 2;  // extra space for emoji
    offC.height = canvasSize * 2;
    const offCtx = offC.getContext('2d');

    offCtx.font = `${size}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",sans-serif`;
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';

    if (color) {
      offCtx.fillStyle = color;
    }
    offCtx.fillText(text, canvasSize, canvasSize);

    const sprite = {
      canvas: offC,
      width: canvasSize * 2,
      height: canvasSize * 2,
      cx: canvasSize,
      cy: canvasSize,
    };

    this._spriteCache.set(key, sprite);
    return sprite;
  }

  /** Draw a cached sprite centered at (x, y) with optional transforms */
  drawSprite(ctx, text, x, y, size = 32, opts = {}) {
    const sprite = this.getSprite(text, size, opts.color);
    const scale = (opts.scale || 1);
    const rotation = opts.rotation || 0;
    const alpha = opts.alpha ?? 1;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x, y);
    if (rotation) ctx.rotate(rotation);
    if (scale !== 1) ctx.scale(scale, scale);
    ctx.drawImage(
      sprite.canvas,
      -sprite.cx, -sprite.cy
    );
    ctx.restore();
  }

  /** Draw a rounded rectangle */
  roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  /** Draw a circle with optional glow */
  drawCircle(ctx, x, y, r, fill, opts = {}) {
    ctx.save();
    if (opts.glow) {
      ctx.shadowColor = opts.glow;
      ctx.shadowBlur = opts.glowSize || 15;
    }
    if (opts.alpha !== undefined) ctx.globalAlpha = opts.alpha;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = fill;
    ctx.fill();
    if (opts.stroke) {
      ctx.strokeStyle = opts.stroke;
      ctx.lineWidth = opts.lineWidth || 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  /** Draw a line with optional glow */
  drawLine(ctx, x1, y1, x2, y2, color, width = 1, opts = {}) {
    ctx.save();
    if (opts.glow) {
      ctx.shadowColor = opts.glow;
      ctx.shadowBlur = opts.glowSize || 8;
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = opts.cap || 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  /** Gradient fill helper */
  createGradient(ctx, x1, y1, x2, y2, stops) {
    const g = ctx.createLinearGradient(x1, y1, x2, y2);
    for (const [pos, color] of stops) g.addColorStop(pos, color);
    return g;
  }

  /** Radial gradient helper */
  createRadialGradient(ctx, cx, cy, r, stops) {
    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    for (const [pos, color] of stops) g.addColorStop(pos, color);
    return g;
  }

  /** Apply 3D tilt transform to the foreground canvas */
  setTilt(x, y) {
    this.tiltX = x;
    this.tiltY = y;
    if (this.perspective > 0) {
      this.fgCanvas.style.transform = `rotateX(${-y}deg) rotateY(${x}deg)`;
    }
  }

  /** Post-processing: bloom/glow effect on the foreground */
  applyBloom(strength = 0.3) {
    const ctx = this.fgCtx;
    const w = this.width;
    const h = this.height;
    this._offCtx.clearRect(0, 0, w, h);
    this._offCtx.filter = `blur(${8 * strength}px) brightness(${1 + strength})`;
    this._offCtx.drawImage(this.fgCanvas, 0, 0, w, h);
    this._offCtx.filter = 'none';

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = strength;
    ctx.drawImage(this._offscreen, 0, 0, w, h);
    ctx.restore();
  }

  /** Screen flash overlay */
  flash(color, alpha = 0.3) {
    const ctx = this.fgCtx;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, this.width, this.height);
    ctx.restore();
  }

  /** Vignette overlay */
  drawVignette(ctx, strength = 0.4) {
    const g = ctx.createRadialGradient(
      this.width / 2, this.height / 2, this.width * 0.25,
      this.width / 2, this.height / 2, this.width * 0.7,
    );
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, `rgba(0,0,0,${strength})`);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, this.width, this.height);
  }

  destroy() {
    this._resizeObserver.disconnect();
    this.bgCanvas.remove();
    this.fgCanvas.remove();
    this._spriteCache.clear();
  }
}


// â”€â”€â”€â”€ engine/particles.js (365 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Particle System (Object-Pooled)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Particle {
  constructor() { this.reset(); }

  reset() {
    this.alive = false;
    this.x = 0; this.y = 0;
    this.vx = 0; this.vy = 0;
    this.ax = 0; this.ay = 0;        // acceleration (gravity etc)
    this.rotation = 0;
    this.rotationSpeed = 0;
    this.scale = 1;
    this.scaleEnd = 0;
    this.alpha = 1;
    this.alphaEnd = 0;
    this.life = 0;
    this.maxLife = 1;
    this.color = '#ffffff';
    this.colorEnd = null;
    this.size = 4;
    this.type = 'circle';            // circle | square | sprite | line
    this.sprite = null;              // emoji string for sprite type
    this.friction = 1;               // velocity multiplier per frame (0.98 = slight drag)
    this.turbulence = 0;
  }
}

class ParticleSystem {
  constructor(maxParticles = 500) {
    this.pool = [];
    this.active = [];
    this.maxParticles = maxParticles;

    // Pre-allocate pool
    for (let i = 0; i < maxParticles; i++) {
      this.pool.push(new Particle());
    }

    // Global forces
    this.gravity = 0;                 // pixels/sÂ²
    this.wind = 0;                    // pixels/s
  }

  /** Get a particle from the pool */
  _acquire() {
    if (this.pool.length > 0) {
      const p = this.pool.pop();
      p.reset();
      p.alive = true;
      this.active.push(p);
      return p;
    }
    // Pool empty â€” steal oldest active
    if (this.active.length > 0) {
      const p = this.active.shift();
      p.reset();
      p.alive = true;
      this.active.push(p);
      return p;
    }
    return null;
  }

  /** Return particle to pool */
  _release(p) {
    p.alive = false;
    this.pool.push(p);
  }

  /** Emit a burst of particles */
  emit(count, config) {
    for (let i = 0; i < count; i++) {
      const p = this._acquire();
      if (!p) return;

      // Position
      if (config.shape === 'circle') {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * (config.radius || 10);
        p.x = (config.x || 0) + Math.cos(angle) * r;
        p.y = (config.y || 0) + Math.sin(angle) * r;
      } else if (config.shape === 'line') {
        const t = Math.random();
        p.x = (config.x || 0) + t * (config.x2 || 0 - (config.x || 0));
        p.y = (config.y || 0) + t * (config.y2 || 0 - (config.y || 0));
      } else if (config.shape === 'rect') {
        p.x = (config.x || 0) + Math.random() * (config.w || 20);
        p.y = (config.y || 0) + Math.random() * (config.h || 20);
      } else {
        p.x = config.x || 0;
        p.y = config.y || 0;
      }

      // Velocity
      if (config.angle !== undefined) {
        const angle = config.angle + (Math.random() - 0.5) * (config.spread || Math.PI * 2);
        const speed = _range(config.speed || 100, config.speedVar || 50);
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
      } else {
        p.vx = _range(config.vx || 0, config.vxVar || 0);
        p.vy = _range(config.vy || 0, config.vyVar || 0);
      }

      // Acceleration
      p.ax = config.ax || 0;
      p.ay = config.ay || 0;

      // Life
      p.maxLife = _range(config.life || 1, config.lifeVar || 0.2);
      p.life = 0;

      // Visual
      p.size = _range(config.size || 4, config.sizeVar || 1);
      p.scale = config.scale ?? 1;
      p.scaleEnd = config.scaleEnd ?? 0.2;
      p.alpha = config.alpha ?? 1;
      p.alphaEnd = config.alphaEnd ?? 0;
      p.rotation = Math.random() * Math.PI * 2;
      p.rotationSpeed = _range(config.rotationSpeed || 0, config.rotationSpeedVar || 2);
      p.friction = config.friction ?? 0.98;
      p.turbulence = config.turbulence || 0;

      // Color
      if (Array.isArray(config.colors) && config.colors.length > 0) {
        p.color = config.colors[Math.floor(Math.random() * config.colors.length)];
      } else {
        p.color = config.color || '#ffffff';
      }
      p.colorEnd = config.colorEnd || null;

      // Type
      p.type = config.type || 'circle';
      if (Array.isArray(config.sprites) && config.sprites.length > 0) {
        p.type = 'sprite';
        p.sprite = config.sprites[Math.floor(Math.random() * config.sprites.length)];
      } else if (config.sprite) {
        p.type = 'sprite';
        p.sprite = config.sprite;
      }
    }
  }

  /** Update all active particles */
  update(dt) {
    for (let i = this.active.length - 1; i >= 0; i--) {
      const p = this.active[i];
      p.life += dt;

      if (p.life >= p.maxLife) {
        this.active.splice(i, 1);
        this._release(p);
        continue;
      }

      // Forces
      p.vy += (this.gravity + p.ay) * dt;
      p.vx += (this.wind + p.ax) * dt;

      // Turbulence
      if (p.turbulence > 0) {
        p.vx += (Math.random() - 0.5) * p.turbulence * dt * 60;
        p.vy += (Math.random() - 0.5) * p.turbulence * dt * 60;
      }

      // Friction
      p.vx *= p.friction;
      p.vy *= p.friction;

      // Integrate
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.rotation += p.rotationSpeed * dt;
    }
  }

  /** Render all active particles */
  render(ctx, renderer) {
    for (const p of this.active) {
      const t = p.life / p.maxLife;     // 0â†’1 normalized lifetime

      const alpha = p.alpha + (p.alphaEnd - p.alpha) * t;
      if (alpha <= 0.01) continue;

      const scale = p.scale + (p.scaleEnd - p.scale) * t;
      const size = p.size * scale;

      if (p.type === 'sprite' && p.sprite && renderer) {
        renderer.drawSprite(ctx, p.sprite, p.x, p.y, size * 2, {
          alpha, scale: 1, rotation: p.rotation,
        });
      } else if (p.type === 'square') {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.colorEnd ? lerpColor(p.color, p.colorEnd, t) : p.color;
        ctx.fillRect(-size / 2, -size / 2, size, size);
        ctx.restore();
      } else if (p.type === 'line') {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = Math.max(1, size * 0.3);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - p.vx * 0.03, p.y - p.vy * 0.03); // velocity trail
        ctx.stroke();
        ctx.restore();
      } else {
        // Circle (default)
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.colorEnd ? lerpColor(p.color, p.colorEnd, t) : p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(0.5, size / 2), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
  }

  /** Clear all particles */
  clear() {
    while (this.active.length > 0) {
      this._release(this.active.pop());
    }
  }

  get count() { return this.active.length; }
}


// â”€â”€ Particle Presets â”€â”€

const ParticlePresets = {
  /** Big win burst from a point */
  burst(x, y, opts = {}) {
    return {
      x, y, shape: 'point',
      angle: -Math.PI / 2,
      spread: Math.PI * 2,
      speed: opts.speed || 200,
      speedVar: opts.speedVar || 100,
      life: opts.life || 0.8,
      lifeVar: 0.3,
      size: opts.size || 6,
      sizeVar: 3,
      scaleEnd: 0,
      alphaEnd: 0,
      friction: 0.96,
      sprites: opts.sprites || null,
      colors: opts.colors || ['#ffd700', '#ff6b6b', '#4ecdc4', '#a78bfa', '#ffffff'],
      type: opts.sprites ? 'sprite' : 'circle',
    };
  },

  /** Confetti rain from top */
  confetti(w, h, opts = {}) {
    return {
      x: 0, y: -20, shape: 'rect', w, h: 1,
      vx: 0, vxVar: 40,
      vy: 120, vyVar: 60,
      life: opts.life || 2.5,
      lifeVar: 0.5,
      size: opts.size || 8,
      sizeVar: 3,
      scaleEnd: 0.6,
      alphaEnd: 0,
      friction: 0.995,
      rotationSpeed: 3, rotationSpeedVar: 4,
      turbulence: 30,
      type: 'square',
      colors: opts.colors || ['#ff6b6b', '#ffd700', '#4ecdc4', '#a78bfa', '#ff8c42', '#7bed9f'],
    };
  },

  /** Sparkle/shimmer at a point */
  sparkle(x, y, opts = {}) {
    return {
      x, y, shape: 'circle', radius: opts.radius || 15,
      speed: 15, speedVar: 10,
      spread: Math.PI * 2,
      life: 0.5, lifeVar: 0.2,
      size: 3, sizeVar: 2,
      alpha: 0.9, alphaEnd: 0,
      scale: 1, scaleEnd: 0,
      color: opts.color || '#ffd700',
      type: 'circle',
    };
  },

  /** Fire effect rising from point */
  fire(x, y, opts = {}) {
    return {
      x, y, shape: 'circle', radius: 8,
      angle: -Math.PI / 2,
      spread: 0.5,
      speed: 80, speedVar: 40,
      life: 0.6, lifeVar: 0.3,
      size: 8, sizeVar: 4,
      scaleEnd: 0,
      alphaEnd: 0,
      friction: 0.97,
      turbulence: 20,
      color: '#ff4500',
      colorEnd: '#ffd700',
    };
  },

  /** Trail behind a moving object */
  trail(x, y, opts = {}) {
    return {
      x, y, shape: 'point',
      speed: 5, speedVar: 3,
      spread: Math.PI * 2,
      life: 0.3, lifeVar: 0.1,
      size: opts.size || 3,
      sizeVar: 1,
      alpha: 0.7, alphaEnd: 0,
      scaleEnd: 0,
      color: opts.color || '#ffd700',
    };
  },

  /** Impact ring expanding outward */
  ring(x, y, opts = {}) {
    return {
      x, y, shape: 'circle', radius: 2,
      speed: opts.speed || 150, speedVar: 30,
      spread: Math.PI * 2,
      life: 0.4, lifeVar: 0.1,
      size: 3, sizeVar: 1,
      alphaEnd: 0, scaleEnd: 0.3,
      friction: 0.94,
      color: opts.color || '#ffffff',
    };
  },

  /** Coins/gems flying up and falling with gravity */
  coins(x, y, opts = {}) {
    return {
      x, y, shape: 'point',
      angle: -Math.PI / 2,
      spread: 1.2,
      speed: 250, speedVar: 100,
      life: 1.5, lifeVar: 0.3,
      size: 12, sizeVar: 4,
      alphaEnd: 0,
      scaleEnd: 0.5,
      friction: 0.99,
      sprites: opts.sprites || ['ğŸª™', 'ğŸ’°', 'ğŸ’'],
      type: 'sprite',
    };
  },
};

// Utility: random value with variance
function _range(base, variance) {
  return base + (Math.random() - 0.5) * 2 * variance;
}


// â”€â”€â”€â”€ engine/physics.js (139 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Physics (Verlet Integration + Collisions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.Physics = (() => {
  const _bodies = [], _statics = [];
  let _gravity = { x: 0, y: 600 }, _bounds = null;

  class Body {
    constructor(opts = {}) {
      this.x = opts.x||0; this.y = opts.y||0;
      this.prevX = this.x; this.prevY = this.y;
      this.ax = 0; this.ay = 0;
      this.radius = opts.radius||5; this.mass = opts.mass||1;
      this.restitution = opts.restitution ?? 0.6;
      this.friction = opts.friction ?? 0.99;
      this.damping = opts.damping ?? 0.999;
      this.active = true; this.userData = opts.userData||null;
      this.onCollide = opts.onCollide||null;
    }
    get vx() { return this.x - this.prevX; }
    get vy() { return this.y - this.prevY; }
    get speed() { return Math.sqrt(this.vx*this.vx + this.vy*this.vy); }
    setVelocity(vx, vy) { this.prevX = this.x - vx; this.prevY = this.y - vy; }
    addForce(fx, fy) { this.ax += fx/this.mass; this.ay += fy/this.mass; }
    impulse(ix, iy) { this.prevX -= ix; this.prevY -= iy; }
  }

  class StaticCircle {
    constructor(x, y, radius, opts={}) { this.x=x; this.y=y; this.radius=radius; this.restitution=opts.restitution??0.5; this.userData=opts.userData||null; this.type='circle'; }
  }
  class StaticLine {
    constructor(x1,y1,x2,y2,opts={}) {
      this.x1=x1;this.y1=y1;this.x2=x2;this.y2=y2;this.restitution=opts.restitution??0.5;this.userData=opts.userData||null;this.type='line';
      const dx=x2-x1,dy=y2-y1; this.length=Math.sqrt(dx*dx+dy*dy); this.nx=-dy/this.length; this.ny=dx/this.length;
    }
  }
  class StaticRect {
    constructor(x,y,w,h,opts={}) { this.x=x;this.y=y;this.w=w;this.h=h;this.restitution=opts.restitution??0.3;this.userData=opts.userData||null;this.type='rect'; }
  }

  function addBody(opts) { const b=new Body(opts); _bodies.push(b); return b; }
  function addCircle(x,y,r,opts) { const s=new StaticCircle(x,y,r,opts); _statics.push(s); return s; }
  function addLine(x1,y1,x2,y2,opts) { const s=new StaticLine(x1,y1,x2,y2,opts); _statics.push(s); return s; }
  function addRect(x,y,w,h,opts) { const s=new StaticRect(x,y,w,h,opts); _statics.push(s); return s; }
  function removeBody(b) { const i=_bodies.indexOf(b); if(i>=0) _bodies.splice(i,1); }
  function removeStatic(s) { const i=_statics.indexOf(s); if(i>=0) _statics.splice(i,1); }
  function clear() { _bodies.length=0; _statics.length=0; }
  function setGravity(x,y) { _gravity.x=x; _gravity.y=y; }
  function setBounds(x,y,w,h) { _bounds={x,y,w,h}; }

  function update(dt) {
    const dtSq = dt*dt;
    for (const b of _bodies) {
      if (!b.active) continue;
      const cx=b.x, cy=b.y;
      b.x = 2*b.x - b.prevX + (b.ax+_gravity.x)*dtSq;
      b.y = 2*b.y - b.prevY + (b.ay+_gravity.y)*dtSq;
      b.prevX = cx + (cx-b.prevX)*(1-(1-b.damping));
      b.prevY = cy + (cy-b.prevY)*(1-(1-b.damping));
      b.ax=0; b.ay=0;
      if (_bounds) {
        if (b.x-b.radius<_bounds.x){b.x=_bounds.x+b.radius;b.prevX=b.x+(b.x-b.prevX)*b.restitution;}
        if (b.x+b.radius>_bounds.x+_bounds.w){b.x=_bounds.x+_bounds.w-b.radius;b.prevX=b.x+(b.x-b.prevX)*b.restitution;}
        if (b.y-b.radius<_bounds.y){b.y=_bounds.y+b.radius;b.prevY=b.y+(b.y-b.prevY)*b.restitution;}
        if (b.y+b.radius>_bounds.y+_bounds.h){b.y=_bounds.y+_bounds.h-b.radius;b.prevY=b.y+(b.y-b.prevY)*b.restitution;}
      }
    }
    _resolveCollisions();
  }

  function _resolveCollisions() {
    for (const b of _bodies) {
      if (!b.active) continue;
      for (const s of _statics) {
        if (s.type==='circle') _bodyVsCircle(b,s);
        else if (s.type==='line') _bodyVsLine(b,s);
        else if (s.type==='rect') _bodyVsRect(b,s);
      }
    }
    for (let i=0;i<_bodies.length;i++) for (let j=i+1;j<_bodies.length;j++) _bodyVsBody(_bodies[i],_bodies[j]);
  }

  function _reflect(b, nx, ny, overlap, sRest) {
    b.x += nx*overlap; b.y += ny*overlap;
    const vx=b.x-b.prevX, vy=b.y-b.prevY;
    const dot = vx*nx + vy*ny;
    const rest = Math.min(b.restitution, sRest);
    b.prevX = b.x - (vx - 2*dot*nx*rest)*b.friction;
    b.prevY = b.y - (vy - 2*dot*ny*rest)*b.friction;
  }

  function _bodyVsCircle(b, s) {
    const dx=b.x-s.x, dy=b.y-s.y, dist=Math.sqrt(dx*dx+dy*dy), minD=b.radius+s.radius;
    if (dist>=minD||dist<0.001) return;
    const nx=dx/dist,ny=dy/dist,overlap=minD-dist;
    _reflect(b,nx,ny,overlap,s.restitution);
    if (b.onCollide) b.onCollide(s,{x:nx,y:ny},overlap);
  }

  function _bodyVsLine(b, s) {
    const dx=s.x2-s.x1, dy=s.y2-s.y1;
    const t=Math.max(0,Math.min(1,((b.x-s.x1)*dx+(b.y-s.y1)*dy)/(s.length*s.length)));
    const cx=s.x1+t*dx, cy=s.y1+t*dy;
    const bx=b.x-cx, by=b.y-cy, dist=Math.sqrt(bx*bx+by*by);
    if (dist>=b.radius||dist<0.001) return;
    const nx=bx/dist,ny=by/dist,overlap=b.radius-dist;
    _reflect(b,nx,ny,overlap,s.restitution);
    if (b.onCollide) b.onCollide(s,{x:nx,y:ny},overlap);
  }

  function _bodyVsRect(b, s) {
    const cx=Math.max(s.x,Math.min(b.x,s.x+s.w)), cy=Math.max(s.y,Math.min(b.y,s.y+s.h));
    const dx=b.x-cx,dy=b.y-cy,dist=Math.sqrt(dx*dx+dy*dy);
    if (dist>=b.radius||dist<0.001) return;
    const nx=dx/dist,ny=dy/dist,overlap=b.radius-dist;
    _reflect(b,nx,ny,overlap,s.restitution);
    if (b.onCollide) b.onCollide(s,{x:nx,y:ny},overlap);
  }

  function _bodyVsBody(a, b2) {
    if (!a.active||!b2.active) return;
    const dx=b2.x-a.x,dy=b2.y-a.y,dist=Math.sqrt(dx*dx+dy*dy),minD=a.radius+b2.radius;
    if (dist>=minD||dist<0.001) return;
    const nx=dx/dist,ny=dy/dist,overlap=minD-dist,totalM=a.mass+b2.mass;
    a.x-=nx*overlap*(b2.mass/totalM); a.y-=ny*overlap*(b2.mass/totalM);
    b2.x+=nx*overlap*(a.mass/totalM); b2.y+=ny*overlap*(a.mass/totalM);
    const av={x:a.x-a.prevX,y:a.y-a.prevY},bv={x:b2.x-b2.prevX,y:b2.y-b2.prevY};
    const relDot=(av.x-bv.x)*nx+(av.y-bv.y)*ny;
    if (relDot>0) return;
    const rest=Math.min(a.restitution,b2.restitution), j=-(1+rest)*relDot/totalM;
    a.prevX=a.x-(av.x-j*b2.mass*nx); a.prevY=a.y-(av.y-j*b2.mass*ny);
    b2.prevX=b2.x-(bv.x+j*a.mass*nx); b2.prevY=b2.y-(bv.y+j*a.mass*ny);
  }

  function raycastBodies(x,y) { return _bodies.filter(b=>{const dx=x-b.x,dy=y-b.y;return dx*dx+dy*dy<=b.radius*b.radius;}); }
  function raycastStatics(x,y) { return _statics.filter(s=>{if(s.type==='circle'){const dx=x-s.x,dy=y-s.y;return dx*dx+dy*dy<=s.radius*s.radius;}if(s.type==='rect') return x>=s.x&&x<=s.x+s.w&&y>=s.y&&y<=s.y+s.h;return false;}); }

  return { Body,StaticCircle,StaticLine,StaticRect, addBody,addCircle,addLine,addRect, removeBody,removeStatic,clear, setGravity,setBounds,update, raycastBodies,raycastStatics, getBodies:()=>_bodies, getStatics:()=>_statics };
})();


// â”€â”€â”€â”€ engine/audio.js (308 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Audio Engine (Procedural Synthesis + SFX)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AudioEngine {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.initialized = false;

    // Volume categories (0-1)
    this.volumes = { master: 0.7, sfx: 0.8, music: 0.3, ui: 0.5, ambient: 0.2 };

    // Category gain nodes
    this.gains = {};

    // Active audio sources for cleanup
    this._activeSources = new Set();

    // Musical key for themed sounds
    this.key = 'C';
    this.scale = 'minor';
    this._scales = {
      major:   [0, 2, 4, 5, 7, 9, 11],
      minor:   [0, 2, 3, 5, 7, 8, 10],
      penta:   [0, 2, 4, 7, 9],
      blues:   [0, 3, 5, 6, 7, 10],
      arab:    [0, 1, 4, 5, 7, 8, 11],    // Egyptian/Middle Eastern
      japan:   [0, 1, 5, 7, 8],            // Japanese pentatonic
    };
    this._noteFreqs = {
      'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
      'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
      'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88,
    };
  }

  /** Initialize audio context (must be called from user gesture) */
  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = this.volumes.master;
      this.master.connect(this.ctx.destination);

      // Create category buses
      for (const cat of ['sfx', 'music', 'ui', 'ambient']) {
        const g = this.ctx.createGain();
        g.gain.value = this.volumes[cat];
        g.connect(this.master);
        this.gains[cat] = g;
      }

      this.initialized = true;
    } catch (e) {
      console.warn('AudioEngine: Web Audio not available', e);
    }
  }

  /** Resume context if suspended */
  resume() {
    if (this.ctx && this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
  }

  /** Set volume for a category */
  setVolume(category, value) {
    this.volumes[category] = value;
    if (category === 'master' && this.master) {
      this.master.gain.value = value;
    } else if (this.gains[category]) {
      this.gains[category].gain.value = value;
    }
  }

  // â”€â”€ Synthesis Primitives â”€â”€

  /** Play a tone with ADSR envelope */
  tone(freq, opts = {}) {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    const {
      type = 'sine',        // sine, square, triangle, sawtooth
      attack = 0.01,
      decay = 0.1,
      sustain = 0.3,
      release = 0.2,
      duration = 0.3,
      volume = 0.5,
      pan = 0,              // -1 to 1
      detune = 0,
      category = 'sfx',
      filter = null,        // { type, freq, Q }
    } = opts;

    const osc = this.ctx.createOscillator();
    osc.type = type;
    osc.frequency.value = freq;
    if (detune) osc.detune.value = detune;

    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(volume, now + attack);
    env.gain.linearRampToValueAtTime(volume * sustain, now + attack + decay);
    env.gain.setValueAtTime(volume * sustain, now + duration - release);
    env.gain.linearRampToValueAtTime(0, now + duration);

    let chain = osc;

    // Optional filter
    if (filter) {
      const filt = this.ctx.createBiquadFilter();
      filt.type = filter.type || 'lowpass';
      filt.frequency.value = filter.freq || 2000;
      filt.Q.value = filter.Q || 1;
      chain.connect(filt);
      chain = filt;
    }

    chain.connect(env);

    // Stereo panning
    if (pan !== 0) {
      const panner = this.ctx.createStereoPanner();
      panner.pan.value = Math.max(-1, Math.min(1, pan));
      env.connect(panner);
      panner.connect(this.gains[category] || this.master);
    } else {
      env.connect(this.gains[category] || this.master);
    }

    osc.start(now);
    osc.stop(now + duration + 0.01);
    this._activeSources.add(osc);
    osc.onended = () => this._activeSources.delete(osc);

    return osc;
  }

  /** Play a noise burst (snare, scratch, impact) */
  noise(opts = {}) {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    const {
      duration = 0.1,
      volume = 0.3,
      attack = 0.001,
      decay = 0.05,
      filterFreq = 3000,
      filterType = 'bandpass',
      category = 'sfx',
    } = opts;

    // White noise buffer
    const bufSize = this.ctx.sampleRate * duration;
    const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

    const source = this.ctx.createBufferSource();
    source.buffer = buf;

    const filt = this.ctx.createBiquadFilter();
    filt.type = filterType;
    filt.frequency.value = filterFreq;

    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(volume, now + attack);
    env.gain.exponentialRampToValueAtTime(0.001, now + duration);

    source.connect(filt);
    filt.connect(env);
    env.connect(this.gains[category] || this.master);

    source.start(now);
    source.stop(now + duration + 0.01);
    this._activeSources.add(source);
    source.onended = () => this._activeSources.delete(source);
  }

  /** Get a note frequency from the current scale */
  noteFreq(degree, octaveOffset = 0) {
    const baseFreq = this._noteFreqs[this.key] || 261.63;
    const scaleNotes = this._scales[this.scale] || this._scales.minor;
    const idx = ((degree % scaleNotes.length) + scaleNotes.length) % scaleNotes.length;
    const octave = Math.floor(degree / scaleNotes.length) + octaveOffset;
    const semitones = scaleNotes[idx] + octave * 12;
    return baseFreq * Math.pow(2, semitones / 12);
  }

  // â”€â”€ High-Level Sound Effects â”€â”€

  /** UI click */
  click() {
    this.tone(800, { type: 'sine', duration: 0.06, volume: 0.2, attack: 0.001, decay: 0.05, sustain: 0, release: 0.01, category: 'ui' });
  }

  /** Button press */
  press() {
    this.tone(600, { type: 'triangle', duration: 0.08, volume: 0.15, category: 'ui' });
    this.tone(900, { type: 'sine', duration: 0.06, volume: 0.1, category: 'ui' });
  }

  /** Win sound â€” ascending arpeggio */
  win(intensity = 1) {
    const notes = [0, 2, 4, 7];
    notes.forEach((n, i) => {
      setTimeout(() => {
        this.tone(this.noteFreq(n, 1), {
          type: 'triangle', duration: 0.2 + intensity * 0.2,
          volume: 0.25 * intensity, attack: 0.01, category: 'sfx',
        });
      }, i * 80);
    });
    // Shimmer
    setTimeout(() => {
      this.tone(this.noteFreq(4, 2), { type: 'sine', duration: 0.4, volume: 0.15, category: 'sfx' });
    }, notes.length * 80);
  }

  /** Big win â€” chord + shimmer */
  bigWin() {
    [0, 4, 7].forEach((n, i) => {
      this.tone(this.noteFreq(n, 1), { type: 'triangle', duration: 0.6, volume: 0.3, attack: 0.01, detune: i * 3, category: 'sfx' });
    });
    this.tone(this.noteFreq(0, 2), { type: 'sine', duration: 0.8, volume: 0.2, attack: 0.05, category: 'sfx' });
    this.noise({ duration: 0.2, volume: 0.15, filterFreq: 8000, category: 'sfx' });
  }

  /** Lose / bust */
  lose() {
    this.tone(200, { type: 'sawtooth', duration: 0.3, volume: 0.25, attack: 0.01, filter: { type: 'lowpass', freq: 600 }, category: 'sfx' });
    this.tone(150, { type: 'sine', duration: 0.4, volume: 0.2, attack: 0.05, category: 'sfx' });
  }

  /** Impact / collision */
  impact(intensity = 0.5) {
    this.noise({ duration: 0.08 + intensity * 0.05, volume: 0.2 + intensity * 0.2, filterFreq: 200 + intensity * 500, filterType: 'lowpass', category: 'sfx' });
    this.tone(80, { type: 'sine', duration: 0.15, volume: 0.2 * intensity, attack: 0.001, category: 'sfx' });
  }

  /** Tick (wheel, plinko bounce) â€” musical, pitched to row/position */
  tick(pitch = 0, pan = 0) {
    const freq = this.noteFreq(pitch, 1);
    this.tone(freq, { type: 'triangle', duration: 0.08, volume: 0.2, attack: 0.001, decay: 0.06, sustain: 0, pan, category: 'sfx' });
  }

  /** Rising tension â€” ascending pitch over duration */
  tension(durationMs, startFreq = 200, endFreq = 800) {
    if (!this.ctx) return null;
    const now = this.ctx.currentTime;
    const dur = durationMs / 1000;
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(startFreq, now);
    osc.frequency.exponentialRampToValueAtTime(endFreq, now + dur);

    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(0.15, now + 0.1);
    env.gain.setValueAtTime(0.15, now + dur - 0.1);
    env.gain.linearRampToValueAtTime(0, now + dur);

    osc.connect(env);
    env.connect(this.gains.ambient || this.master);
    osc.start(now);
    osc.stop(now + dur);
    this._activeSources.add(osc);
    osc.onended = () => this._activeSources.delete(osc);
    return osc;
  }

  /** Coin collect sound */
  coin(pitch = 0) {
    const freq = 1200 + pitch * 100;
    this.tone(freq, { type: 'square', duration: 0.08, volume: 0.15, attack: 0.001, filter: { type: 'highpass', freq: 800 }, category: 'sfx' });
    this.tone(freq * 1.5, { type: 'sine', duration: 0.12, volume: 0.1, attack: 0.01, category: 'sfx' });
  }

  /** Card flip sound */
  cardFlip() {
    this.noise({ duration: 0.04, volume: 0.2, filterFreq: 5000, filterType: 'highpass', category: 'sfx' });
    this.tone(1200, { type: 'sine', duration: 0.04, volume: 0.08, category: 'sfx' });
  }

  /** Scratch sound (for scratch cards) */
  scratch() {
    this.noise({ duration: 0.06, volume: 0.15, filterFreq: 4000, filterType: 'bandpass', category: 'sfx' });
  }

  /** Stop all active sounds */
  stopAll() {
    for (const src of this._activeSources) {
      try { src.stop(); } catch (e) {}
    }
    this._activeSources.clear();
  }

  destroy() {
    this.stopAll();
    if (this.ctx) {
      this.ctx.close().catch(() => {});
    }
  }
}


// â”€â”€â”€â”€ engine/camera.js (159 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Camera & Screen Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Camera {
  constructor(renderer) {
    this.renderer = renderer;
    this.x = 0;
    this.y = 0;
    this.zoom = 1;
    this.targetZoom = 1;
    this.zoomSpeed = 3;

    // Shake
    this._shakeAmp = 0;
    this._shakeFreq = 30;
    this._shakeDecay = 0;
    this._shakeT = 0;
    this._shakeDirX = 0;
    this._shakeDirY = 0;

    // Follow
    this._followTarget = null;
    this._followLag = 0.1;

    // Flash
    this._flashColor = '#fff';
    this._flashAlpha = 0;
    this._flashDecayRate = 3;

    // Vignette
    this.vignette = 0;
    this.vignetteTarget = 0;

    // Chromatic aberration
    this.aberration = 0;
    this._aberDecay = 5;

    // Slow motion pulse
    this.slowMoTarget = 1;

    // Output
    this.offsetX = 0;
    this.offsetY = 0;
  }

  shake(amp = 8, freq = 30, dur = 0.4, dirX = 0, dirY = 0) {
    this._shakeAmp = amp;
    this._shakeFreq = freq;
    this._shakeDecay = amp / Math.max(dur, 0.05);
    this._shakeT = 0;
    this._shakeDirX = dirX;
    this._shakeDirY = dirY;
  }

  impact(strength = 1) {
    this.shake(6 * strength, 35, 0.3 + strength * 0.15);
    this.flash('#ffffff', 0.15 * strength);
    this.aberration = 3 * strength;
  }

  zoomTo(target, speed = 3) { this.targetZoom = target; this.zoomSpeed = speed; }

  zoomPulse(amount = 0.1, dur = 0.3) {
    const orig = this.targetZoom;
    this.targetZoom = orig + amount;
    this.zoomSpeed = 8;
    setTimeout(() => { this.targetZoom = orig; this.zoomSpeed = 4; }, dur * 1000);
  }

  follow(target, lag = 0.1) { this._followTarget = target; this._followLag = lag; }
  stopFollow() { this._followTarget = null; }

  flash(color = '#ffffff', alpha = 0.3) {
    this._flashColor = color;
    this._flashAlpha = Math.max(this._flashAlpha, alpha);
  }

  setVignette(v) { this.vignetteTarget = v; }

  update(dt) {
    // Shake
    if (this._shakeAmp > 0.1) {
      this._shakeT += dt;
      const decay = Math.max(0, this._shakeAmp - this._shakeDecay * this._shakeT);
      const p = this._shakeT * this._shakeFreq * Math.PI * 2;
      this.offsetX = Math.sin(p) * decay + this._shakeDirX * decay;
      this.offsetY = Math.cos(p * 1.3) * decay + this._shakeDirY * decay;
      if (decay <= 0.1) { this._shakeAmp = 0; this.offsetX = 0; this.offsetY = 0; }
    }

    // Follow
    if (this._followTarget) {
      const cx = this.renderer.width / 2;
      const cy = this.renderer.height / 2;
      const lerp = 1 - Math.pow(this._followLag, dt * 60);
      this.x += (this._followTarget.x - cx - this.x) * lerp;
      this.y += (this._followTarget.y - cy - this.y) * lerp;
    }

    // Zoom
    if (Math.abs(this.zoom - this.targetZoom) > 0.0005) {
      this.zoom += (this.targetZoom - this.zoom) * Math.min(1, this.zoomSpeed * dt);
    }

    // Flash
    if (this._flashAlpha > 0) {
      this._flashAlpha = Math.max(0, this._flashAlpha - this._flashDecayRate * dt);
    }

    // Vignette
    this.vignette += (this.vignetteTarget - this.vignette) * Math.min(1, 2 * dt);

    // Aberration
    if (this.aberration > 0) {
      this.aberration = Math.max(0, this.aberration - this._aberDecay * dt);
    }
  }

  /** Apply transform to ctx before drawing game content */
  applyTransform(ctx) {
    const cx = this.renderer.width / 2;
    const cy = this.renderer.height / 2;
    ctx.save();
    ctx.translate(cx + this.offsetX, cy + this.offsetY);
    ctx.scale(this.zoom, this.zoom);
    ctx.translate(-cx - this.x, -cy - this.y);
  }

  restoreTransform(ctx) { ctx.restore(); }

  /** Render screen-space post effects (flash, vignette, aberration) */
  renderEffects(ctx) {
    const w = this.renderer.width;
    const h = this.renderer.height;

    if (this._flashAlpha > 0.005) {
      ctx.save();
      ctx.globalAlpha = this._flashAlpha;
      ctx.fillStyle = this._flashColor;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
    }

    if (this.vignette > 0.01) {
      this.renderer.drawVignette(ctx, this.vignette);
    }

    if (this.aberration > 0.5) {
      const a = this.aberration;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.08;
      ctx.drawImage(ctx.canvas, a, 0);
      ctx.drawImage(ctx.canvas, -a, 0);
      ctx.restore();
    }
  }
}


// â”€â”€â”€â”€ engine/input.js (118 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Input System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.Input = (() => {
  let _container = null, _enabled = true;
  const pointer = { x:0, y:0, down:false, pressed:false, released:false, dragging:false };
  let _downX=0, _downY=0, _downTime=0, _longPressTimer=null;
  const DRAG_THRESHOLD=8, LONG_PRESS_MS=500;
  let _swipeDir=null, _swipeVel=0;
  let _tapCb=null, _longPressCb=null, _swipeCb=null, _dragCb=null, _dragEndCb=null, _hoverCb=null;
  const _regions = [];

  function init(containerId) {
    _container = document.getElementById(containerId);
    if (!_container) return;
    _container.style.touchAction = 'none';
    _container.style.userSelect = 'none';
    _container.style.webkitUserSelect = 'none';
    _container.addEventListener('pointerdown', _onDown, {passive:false});
    _container.addEventListener('pointermove', _onMove, {passive:false});
    _container.addEventListener('pointerup', _onUp, {passive:false});
    _container.addEventListener('pointercancel', _onUp, {passive:false});
    _container.addEventListener('pointerleave', _onLeave, {passive:false});
    _container.addEventListener('contextmenu', e=>e.preventDefault());
    let lastTap=0;
    _container.addEventListener('touchend', e=>{ const n=Date.now(); if(n-lastTap<300) e.preventDefault(); lastTap=n; }, {passive:false});
  }

  function _pos(e) { const r=_container.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }

  function _onDown(e) {
    if(!_enabled) return; e.preventDefault();
    const p=_pos(e); pointer.x=p.x; pointer.y=p.y;
    pointer.down=true; pointer.pressed=true; pointer.dragging=false;
    _downX=p.x; _downY=p.y; _downTime=performance.now(); _swipeDir=null;
    if(_longPressTimer) clearTimeout(_longPressTimer);
    _longPressTimer = setTimeout(()=>{ if(pointer.down&&!pointer.dragging){ if(_longPressCb) _longPressCb(p.x,p.y); haptic('heavy'); } }, LONG_PRESS_MS);
    _checkRegions(p.x,p.y,'down');
    ARCADE.Audio.unlock();
  }

  function _onMove(e) {
    if(!_enabled) return; e.preventDefault();
    const p=_pos(e); pointer.x=p.x; pointer.y=p.y;
    if(pointer.down) {
      const dx=p.x-_downX, dy=p.y-_downY;
      if(Math.sqrt(dx*dx+dy*dy)>DRAG_THRESHOLD && !pointer.dragging) {
        pointer.dragging=true; if(_longPressTimer){clearTimeout(_longPressTimer);_longPressTimer=null;}
      }
      if(pointer.dragging && _dragCb) _dragCb(p.x,p.y,dx,dy);
    }
    if(!pointer.down && _hoverCb) _hoverCb(p.x,p.y);
    _checkRegions(p.x,p.y,pointer.down?'drag':'hover');
  }

  function _onUp(e) {
    if(!_enabled) return; e.preventDefault();
    const p=_pos(e); pointer.x=p.x; pointer.y=p.y;
    pointer.down=false; pointer.released=true;
    if(_longPressTimer){clearTimeout(_longPressTimer);_longPressTimer=null;}
    if(!pointer.dragging) {
      if(_tapCb) _tapCb(p.x,p.y);
      _checkRegions(p.x,p.y,'tap');
    } else {
      const dx=p.x-_downX,dy=p.y-_downY,dist=Math.sqrt(dx*dx+dy*dy);
      const elapsed=(performance.now()-_downTime)/1000;
      _swipeVel=dist/Math.max(elapsed,0.01);
      if(dist>30&&_swipeVel>100) {
        _swipeDir = Math.abs(dx)>Math.abs(dy) ? (dx>0?'right':'left') : (dy>0?'down':'up');
        if(_swipeCb) _swipeCb(_swipeDir,_swipeVel);
      }
      if(_dragEndCb) _dragEndCb(p.x,p.y);
    }
    pointer.dragging=false;
    _checkRegions(p.x,p.y,'up');
  }

  function _onLeave(e) { if(pointer.down) _onUp(e); _checkRegions(-1,-1,'leave'); }

  function addRegion(id,x,y,w,h,cbs) { _regions.push({id,x,y,w,h,...cbs,hovered:false}); return id; }
  function updateRegion(id,props) { const r=_regions.find(r=>r.id===id); if(r) Object.assign(r,props); }
  function removeRegion(id) { const i=_regions.findIndex(r=>r.id===id); if(i>=0) _regions.splice(i,1); }
  function clearRegions() { _regions.length=0; }

  function _checkRegions(px,py,event) {
    for(const r of _regions) {
      const inside=px>=r.x&&px<r.x+r.w&&py>=r.y&&py<r.y+r.h;
      if(event==='hover'||event==='drag') {
        if(inside&&!r.hovered){r.hovered=true;if(r.enter) r.enter(r.id);}
        if(!inside&&r.hovered){r.hovered=false;if(r.leave) r.leave(r.id);}
      }
      if(event==='leave'&&r.hovered){r.hovered=false;if(r.leave) r.leave(r.id);}
      if(!inside) continue;
      if(event==='tap'&&r.tap) r.tap(r.id,px,py);
      if(event==='down'&&r.down) r.down(r.id,px,py);
      if(event==='up'&&r.up) r.up(r.id,px,py);
    }
  }

  function onTap(fn){_tapCb=fn;} function onLongPress(fn){_longPressCb=fn;}
  function onSwipe(fn){_swipeCb=fn;} function onDrag(fn){_dragCb=fn;}
  function onDragEnd(fn){_dragEndCb=fn;} function onHover(fn){_hoverCb=fn;}

  function haptic(style='light') {
    if(!navigator.vibrate) return;
    const patterns={light:[10],medium:[15,30,15],heavy:[100],success:[10,20,10,20,30],error:[50,30,50],double:[10,40,10]};
    navigator.vibrate(patterns[style]||[10]);
  }

  function endFrame() { pointer.pressed=false; pointer.released=false; _swipeDir=null; }

  return {
    init, pointer, enable(){_enabled=true;}, disable(){_enabled=false;}, endFrame,
    onTap, onLongPress, onSwipe, onDrag, onDragEnd, onHover,
    addRegion, updateRegion, removeRegion, clearRegions,
    haptic, getSwipe:()=>_swipeDir, getSwipeVelocity:()=>_swipeVel,
  };
})();


// â”€â”€â”€â”€ effects/effects.js (118 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Visual Effects (Numbers, Trails, Glow)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Floating Numbers â”€â”€
ARCADE.Numbers = (() => {
  const _nums = [], MAX = 30;
  function spawn(x,y,text,opts={}) {
    if(_nums.length>=MAX) _nums.shift();
    _nums.push({ x,y, text:String(text), vx:opts.vx||(Math.random()-.5)*20, vy:opts.vy||-80,
      life:0, maxLife:opts.duration||1.2, size:opts.size||18, sizeEnd:opts.sizeEnd||24,
      color:opts.color||'#22c55e', glow:opts.glow||null,
      font:opts.font||'bold {size}px Inter, sans-serif', ease:opts.ease||ARCADE.Ease.outCubic });
  }
  function update(dt) {
    for(let i=_nums.length-1;i>=0;i--){ const n=_nums[i]; n.life+=dt; if(n.life>=n.maxLife){_nums.splice(i,1);continue;} n.x+=n.vx*dt; n.y+=n.vy*dt; n.vy*=0.97; }
  }
  function render(ctx) {
    for(const n of _nums) {
      const t=n.life/n.maxLife, alpha=t<.2?t/.2:1-ARCADE.Ease.inQuad((t-.2)/.8);
      const size=n.size+(n.sizeEnd-n.size)*n.ease(Math.min(t*2,1));
      if(alpha<=0.01) continue;
      ctx.save(); ctx.globalAlpha=alpha;
      ctx.font=n.font.replace('{size}',size.toFixed(0));
      ctx.textAlign='center'; ctx.textBaseline='middle';
      if(n.glow){ctx.shadowColor=n.glow;ctx.shadowBlur=12;}
      ctx.fillStyle=n.color; ctx.fillText(n.text,n.x,n.y); ctx.restore();
    }
  }
  return { spawn, update, render, clear(){_nums.length=0;} };
})();

// â”€â”€ Odometer â”€â”€
ARCADE.Odometer = class {
  constructor(opts={}) {
    this.value=opts.value||0; this._display=opts.value||0; this._target=opts.value||0;
    this._decimals=opts.decimals??2; this._prefix=opts.prefix||''; this._suffix=opts.suffix||'';
    this._spring=new ARCADE.Spring({value:0,target:0,stiffness:150,damping:14}); this._rolling=false;
  }
  set(val,animate=true) {
    this._target=val; this.value=val;
    if(animate){this._spring.value=this._display;this._spring.target=val;this._spring.velocity=0;this._spring.settled=false;this._rolling=true;}
    else{this._display=val;this._spring.snap(val);this._rolling=false;}
  }
  update(dt) {
    if(!this._rolling) return;
    this._display=this._spring.update(dt);
    if(this._spring.settled){this._display=this._target;this._rolling=false;}
  }
  getText() { return this._prefix+this._display.toFixed(this._decimals)+this._suffix; }
  render(ctx,x,y,opts={}) {
    ctx.save(); ctx.font=opts.font||'bold 24px Inter, sans-serif';
    ctx.fillStyle=opts.color||'#e2e8f0'; ctx.textAlign=opts.align||'center'; ctx.textBaseline=opts.baseline||'middle';
    if(this._rolling&&opts.glow){ctx.shadowColor=opts.glow;ctx.shadowBlur=8;}
    ctx.fillText(this.getText(),x,y); ctx.restore();
  }
};

// â”€â”€ Trail â”€â”€
ARCADE.Trail = class {
  constructor(opts={}) {
    this._pts=[]; this._max=opts.maxPoints||20; this._width=opts.width||4;
    this._widthEnd=opts.widthEnd||0; this._color=opts.color||'#ffffff';
    this._alpha=opts.alpha||0.6; this._fade=opts.fadeSpeed||3;
  }
  addPoint(x,y) { this._pts.push({x,y,alpha:this._alpha}); if(this._pts.length>this._max) this._pts.shift(); }
  update(dt) { for(let i=this._pts.length-1;i>=0;i--){this._pts[i].alpha-=this._fade*dt;if(this._pts[i].alpha<=0) this._pts.splice(i,1);} }
  render(ctx) {
    if(this._pts.length<2) return;
    ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';
    for(let i=1;i<this._pts.length;i++) {
      const prev=this._pts[i-1],cur=this._pts[i],t=i/this._pts.length;
      ctx.beginPath(); ctx.moveTo(prev.x,prev.y); ctx.lineTo(cur.x,cur.y);
      ctx.strokeStyle=this._color; ctx.globalAlpha=cur.alpha*t;
      ctx.lineWidth=this._width+(this._widthEnd-this._width)*(1-t); ctx.stroke();
    }
    ctx.restore();
  }
  clear() { this._pts.length=0; }
};

// â”€â”€ Glow Ring â”€â”€
ARCADE.GlowRing = (() => {
  const _rings = [];
  function spawn(x,y,opts={}) { _rings.push({x,y,radius:opts.radius||5,maxRadius:opts.maxRadius||60,life:0,maxLife:opts.duration||0.4,color:opts.color||'#ffffff',width:opts.width||3}); }
  function update(dt) { for(let i=_rings.length-1;i>=0;i--){_rings[i].life+=dt;if(_rings[i].life>=_rings[i].maxLife) _rings.splice(i,1);} }
  function render(ctx) {
    for(const r of _rings) {
      const t=r.life/r.maxLife, radius=r.radius+(r.maxRadius-r.radius)*ARCADE.Ease.outCubic(t);
      const alpha=1-ARCADE.Ease.inQuad(t); if(alpha<=0.01) continue;
      ctx.save(); ctx.globalAlpha=alpha; ctx.strokeStyle=r.color;
      ctx.lineWidth=r.width*(1-t*0.5); ctx.beginPath(); ctx.arc(r.x,r.y,radius,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }
  return { spawn, update, render, clear(){_rings.length=0;} };
})();

// â”€â”€ Edge Pulse â”€â”€
ARCADE.EdgePulse = (() => {
  let _active=false, _color='#22c55e', _alpha=0, _dur=0, _el=0;
  function trigger(color='#22c55e',dur=0.5) { _color=color;_alpha=1;_dur=dur;_el=0;_active=true; }
  function update(dt) { if(!_active) return; _el+=dt; _alpha=Math.max(0,1-_el/_dur); if(_alpha<=0) _active=false; }
  function render(ctx,w,h) {
    if(!_active||_alpha<=0.01) return;
    ctx.save(); ctx.globalAlpha=_alpha*0.4;
    const s=32;
    const gT=ctx.createLinearGradient(0,0,0,s); gT.addColorStop(0,_color); gT.addColorStop(1,'transparent');
    ctx.fillStyle=gT; ctx.fillRect(0,0,w,s);
    const gB=ctx.createLinearGradient(0,h,0,h-s); gB.addColorStop(0,_color); gB.addColorStop(1,'transparent');
    ctx.fillStyle=gB; ctx.fillRect(0,h-s,w,s);
    const gL=ctx.createLinearGradient(0,0,s,0); gL.addColorStop(0,_color); gL.addColorStop(1,'transparent');
    ctx.fillStyle=gL; ctx.fillRect(0,0,s,h);
    const gR=ctx.createLinearGradient(w,0,w-s,0); gR.addColorStop(0,_color); gR.addColorStop(1,'transparent');
    ctx.fillStyle=gR; ctx.fillRect(w-s,0,s,h);
    ctx.restore();
  }
  return { trigger, update, render };
})();


// â”€â”€â”€â”€ themes/theme_engine.js (58 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Theme System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.Theme = (() => {
  let _current = null;
  const _colors = {};

  function apply(design) {
    _current = design;
    const ui = design.ui_theme || {};
    _colors.primary = ui.primary_color || '#7c6aef';
    _colors.secondary = ui.secondary_color || '#22c55e';
    _colors.accent = ui.accent_color || _colors.primary;
    _colors.danger = ui.danger_color || '#ef4444';
    _colors.text = ui.text_color || '#e2e8f0';
    _colors.dim = ui.dim_color || '#94a3b8';
    _colors.glow = ui.glow_color || _colors.secondary;
    _colors.card = ui.card_bg || 'rgba(255,255,255,0.06)';
    _colors.bg = ui.bg_gradient || ['#0a0a1a', '#1a1a3e'];
    const pal = _detectPalette(design);
    ARCADE.Audio.applyPalette(pal);
  }

  function _detectPalette(d) {
    const t = ((d.title||'') + ' ' + (d.tagline||'')).toLowerCase();
    const map = [['egyptian',['egypt','pharaoh','pyramid']],['cyberpunk',['cyber','neon','hack','matrix']],
      ['ocean',['ocean','sea','underwater','atlantis','trident']],['fire',['fire','flame','dragon','volcano']],
      ['arctic',['ice','arctic','frozen','glacier']],['jungle',['jungle','forest','safari']],
      ['luxury',['luxury','gold','diamond','royal','vault']],['space',['space','galaxy','cosmic','star']]];
    for (const [name, kws] of map) if (kws.some(k=>t.includes(k))) return name;
    return 'default';
  }

  function color(name) { return _colors[name] || '#ffffff'; }
  function colors() { return {..._colors}; }
  function icons() { return _current?.icons || {}; }
  function particles() { return _current?.win_particles || ['âœ¨','ğŸŒŸ','ğŸ’«','â­','ğŸ†']; }
  function titleFont() { return _current?.title_font || "'Inter', sans-serif"; }
  function bodyFont() { return _current?.body_font || "'Inter', sans-serif"; }
  function design() { return _current; }
  function winColors() { return [_colors.secondary, _colors.glow, _colors.accent, '#ffffff']; }
  function loseColors() { return [_colors.danger, '#991b1b', '#7f1d1d']; }

  function renderBackground(ctx, w, h) {
    const bg = _colors.bg;
    if (Array.isArray(bg) && bg.length >= 2) {
      const g = ctx.createLinearGradient(0,0,w*0.3,h);
      g.addColorStop(0, bg[0]); g.addColorStop(1, bg[1]);
      ctx.fillStyle = g;
    } else { ctx.fillStyle = bg[0] || '#0a0a1a'; }
    ctx.fillRect(0,0,w,h);
    const rg = ctx.createRadialGradient(w*.3,h*.7,0,w*.3,h*.7,Math.max(w,h)*.5);
    rg.addColorStop(0, _colors.primary+'08'); rg.addColorStop(1, 'transparent');
    ctx.fillStyle=rg; ctx.fillRect(0,0,w,h);
  }

  return { apply, color, colors, icons, particles, titleFont, bodyFont, design, winColors, loseColors, renderBackground };
})();


// â”€â”€â”€â”€ engine/game.js (256 lines) â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Provably Fair RNG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.Fair = (() => {
  let serverSeed = '', clientSeed = '', nonce = 0, serverHash = '';

  async function init() {
    serverSeed = crypto.randomUUID();
    clientSeed = crypto.randomUUID().slice(0, 8);
    nonce = 0;
    serverHash = await sha256(serverSeed);
    return { serverHash, clientSeed, nonce };
  }

  async function sha256(msg) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(msg));
    return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  async function random() {
    nonce++;
    const hash = await sha256(serverSeed + ':' + clientSeed + ':' + nonce);
    return parseInt(hash.slice(0, 8), 16) / 0xFFFFFFFF;
  }

  async function randomN(n) {
    nonce++;
    const vals = [];
    let hash = await sha256(serverSeed + ':' + clientSeed + ':' + nonce);
    for (let i = 0; i < n; i++) {
      const offset = (i % 7) * 8;
      if (offset + 8 > hash.length) {
        hash = await sha256(hash + ':' + i);
      }
      vals.push(parseInt(hash.slice(offset, offset + 8), 16) / 0xFFFFFFFF);
    }
    return vals;
  }

  async function shuffle(arr) {
    const rs = await randomN(arr.length);
    const result = [...arr];
    for (let i = result.length - 1; i > 0; i--) {
      const j = Math.floor(rs[i] * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }

  function getInfo() { return { serverHash, clientSeed, nonce }; }
  function reveal() { return { serverSeed, clientSeed, nonce }; }

  return { init, random, randomN, shuffle, getInfo, reveal, sha256 };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Base Game Class
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.BaseGame = class {
  constructor(config, design) {
    this.config = config || {};
    this.design = design || {};
    this.balance = 1000;
    this.currentBet = 1;
    this.profit = 0;
    this.history = [];
    this.playing = false;

    // UI elements
    this._balanceOdo = new ARCADE.Odometer({ value: 1000, prefix: (design.currency_symbol || '$'), decimals: 2 });
    this._profitOdo = new ARCADE.Odometer({ value: 0, prefix: (design.currency_symbol || '$'), decimals: 2 });
    this._multOdo = new ARCADE.Odometer({ value: 0, decimals: 2, suffix: 'x' });

    // Sprite cache for themed icons
    this._iconSprites = {};
    this._particleSprites = [];
  }

  // â”€â”€ Override these in subclass â”€â”€
  onInit() {} // called once after engine starts
  onPlay() {} // called when PLAY is pressed
  onReset() {} // called to reset game state
  renderBg(ctx, w, h) {} // background layer
  renderFg(ctx, w, h, alpha, dt) {} // foreground layer (every frame)
  renderUI(ctx, w, h) {} // UI overlay

  // â”€â”€ Lifecycle â”€â”€
  init() {
    // Cache icon sprites
    const icons = ARCADE.Theme.icons();
    for (const [key, emoji] of Object.entries(icons)) {
      this._iconSprites[key] = ARCADE.Renderer.getSprite(emoji, 32);
    }
    // Cache particle sprites
    for (const emoji of ARCADE.Theme.particles()) {
      this._particleSprites.push(ARCADE.Renderer.getSprite(emoji, 20));
    }
    this.onInit();
  }

  startPlay() {
    if (this.playing) return;
    if (this.balance < this.currentBet) {
      ARCADE.Audio.loseThud();
      ARCADE.Camera.shake(4, 0.2);
      return;
    }
    this.playing = true;
    this.balance -= this.currentBet;
    this._balanceOdo.set(this.balance);
    ARCADE.setState(ARCADE.STATES.PLAYING);
    ARCADE.Audio.click();
    ARCADE.Input.haptic('light');
    this.onPlay();
  }

  win(multiplier) {
    const amount = this.currentBet * multiplier;
    this.balance += amount;
    this.profit += amount - this.currentBet;
    this._balanceOdo.set(this.balance);
    this._profitOdo.set(this.profit);
    this.history.unshift({ mult: multiplier, amount, win: true });
    if (this.history.length > 50) this.history.length = 50;

    // Effects
    const w = ARCADE.Renderer.getWidth(), h = ARCADE.Renderer.getHeight();
    ARCADE.Particles.burst(w/2, h/2, {
      count: Math.min(multiplier * 10, 60),
      speed: 150 + multiplier * 20,
      colors: ARCADE.Theme.winColors(),
      sprites: this._particleSprites,
      gravity: 300,
    });
    ARCADE.Camera.zoomPulse(1.05 + Math.min(multiplier * 0.02, 0.15));
    ARCADE.FX.flash(ARCADE.Theme.color('secondary'), 0.15);
    ARCADE.EdgePulse.trigger(ARCADE.Theme.color('secondary'), 0.5);
    ARCADE.Audio.winChime(multiplier);
    ARCADE.Audio.coinDrop(Math.min(Math.ceil(multiplier), 8));
    ARCADE.Input.haptic('success');

    ARCADE.Numbers.spawn(w/2, h/2 - 30,
      '+' + (this.design.currency_symbol || '$') + amount.toFixed(2),
      { color: ARCADE.Theme.color('secondary'), glow: ARCADE.Theme.color('glow'), size: 22, sizeEnd: 30 }
    );
    ARCADE.Numbers.spawn(w/2, h/2 + 10,
      multiplier.toFixed(2) + 'x',
      { color: '#ffffff', size: 16, sizeEnd: 20, vy: -60, duration: 1.5 }
    );

    this.playing = false;
    ARCADE.setState(ARCADE.STATES.RESULT);
    ARCADE.emit('win', { multiplier, amount });
  }

  lose() {
    this.profit -= this.currentBet;
    this._profitOdo.set(this.profit);
    this.history.unshift({ mult: 0, amount: -this.currentBet, win: false });
    if (this.history.length > 50) this.history.length = 50;

    // Effects
    ARCADE.Camera.shake(8, 0.4);
    ARCADE.FX.flash(ARCADE.Theme.color('danger'), 0.2);
    ARCADE.Audio.loseThud();
    ARCADE.Input.haptic('error');

    const w = ARCADE.Renderer.getWidth(), h = ARCADE.Renderer.getHeight();
    ARCADE.Numbers.spawn(w/2, h/2,
      '-' + (this.design.currency_symbol || '$') + this.currentBet.toFixed(2),
      { color: ARCADE.Theme.color('danger'), glow: '#ff000044', size: 18, sizeEnd: 22 }
    );

    this.playing = false;
    ARCADE.setState(ARCADE.STATES.RESULT);
    ARCADE.emit('lose', { amount: this.currentBet });
  }

  setBet(amount) {
    if (this.playing) return;
    this.currentBet = amount;
    ARCADE.Audio.tick();
    ARCADE.emit('betChange', { amount });
  }

  // â”€â”€ Update/render wrappers (called by engine systems) â”€â”€
  _update(dt) {
    this._balanceOdo.update(dt);
    this._profitOdo.update(dt);
    this._multOdo.update(dt);
    ARCADE.Camera.update(dt);
    ARCADE.FX.update(dt);
    ARCADE.Numbers.update(dt);
    ARCADE.GlowRing.update(dt);
    ARCADE.EdgePulse.update(dt);
  }

  _renderBg(ctx, w, h) {
    ARCADE.Theme.renderBackground(ctx, w, h);
    this.renderBg(ctx, w, h);
  }

  _renderFg(ctx, w, h, alpha, dt) {
    ARCADE.Camera.apply(ctx);
    this.renderFg(ctx, w, h, alpha, dt);
    ARCADE.Camera.restore(ctx);
    ARCADE.GlowRing.render(ctx);
  }

  _renderUI(ctx, w, h) {
    this.renderUI(ctx, w, h);
    ARCADE.Numbers.render(ctx);
    ARCADE.EdgePulse.render(ctx, w, h);
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE ENGINE â€” Bootstrap Helper
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCADE.boot = async function(GameClass, containerId, config, design) {
  // Apply theme
  ARCADE.Theme.apply(design);

  // Init renderer
  ARCADE.Renderer.init(containerId);

  // Init input
  ARCADE.Input.init(containerId);

  // Init audio (will be unlocked on first interaction)
  ARCADE.Audio.init();

  // Register particle system
  ARCADE.registerSystem(ARCADE.Particles.sys);

  // Register FX system
  ARCADE.registerSystem(ARCADE.FX.sys);

  // Init RNG
  await ARCADE.Fair.init();

  // Create game
  const game = new GameClass(config, design);

  // Wire up engine
  ARCADE._registerUpdate(dt => game._update(dt));
  ARCADE.Renderer.setBgRenderer((ctx, w, h) => game._renderBg(ctx, w, h));
  ARCADE.Renderer.setFgRenderer((ctx, w, h, alpha, dt) => game._renderFg(ctx, w, h, alpha, dt));
  ARCADE.Renderer.setUIRenderer((ctx, w, h) => game._renderUI(ctx, w, h));

  // Start
  game.init();
  ARCADE.start();

  return game;
};


// â”€â”€â”€â”€ Total: 2384 lines â”€â”€â”€â”€


// â”€â”€â”€â”€ Test Game (validates all subsystems) â”€â”€â”€â”€
class TestGame extends ARCADE.BaseGame {
  constructor(config, design) {
    super(config, design);
    this._testParticle = null;
    this._testSpring = new ARCADE.Spring({ value: 0, target: 0, stiffness: 200, damping: 12 });
  }

  onInit() {
    console.log('âœ… Game.onInit()');
    
    // Test all subsystems exist
    const checks = [
      ['ARCADE.Ease', typeof ARCADE.Ease.outCubic === 'function'],
      ['ARCADE.Spring', typeof ARCADE.Spring === 'function'],
      ['ARCADE.Tween', typeof ARCADE.Tween.tween === 'function'],
      ['ARCADE.Renderer', typeof ARCADE.Renderer.init === 'function'],
      ['ARCADE.Particles', typeof ARCADE.Particles.burst === 'function'],
      ['ARCADE.Physics', typeof ARCADE.Physics.addBody === 'function'],
      ['ARCADE.Audio', typeof ARCADE.Audio.init === 'function'],
      ['ARCADE.Camera', typeof ARCADE.Camera.shake === 'function'],
      ['ARCADE.Input', typeof ARCADE.Input.init === 'function'],
      ['ARCADE.Numbers', typeof ARCADE.Numbers.spawn === 'function'],
      ['ARCADE.Odometer', typeof ARCADE.Odometer === 'function'],
      ['ARCADE.Trail', typeof ARCADE.Trail === 'function'],
      ['ARCADE.GlowRing', typeof ARCADE.GlowRing.spawn === 'function'],
      ['ARCADE.EdgePulse', typeof ARCADE.EdgePulse.trigger === 'function'],
      ['ARCADE.Theme', typeof ARCADE.Theme.apply === 'function'],
      ['ARCADE.Fair', typeof ARCADE.Fair.random === 'function'],
      ['ARCADE.BaseGame', typeof ARCADE.BaseGame === 'function'],
    ];
    
    let passed = 0;
    for (const [name, ok] of checks) {
      if (ok) passed++;
      else console.error('âŒ Missing:', name);
    }
    console.log(`Subsystem check: ${passed}/${checks.length} passed`);
    document.getElementById('status').textContent = `Engine loaded: ${passed}/${checks.length} subsystems âœ…`;
    
    // Test easing functions
    const easings = Object.keys(ARCADE.Ease).filter(k => typeof ARCADE.Ease[k] === 'function');
    console.log(`Easing functions: ${easings.length}`);
    
    // Test spring
    this._testSpring.setTarget(100);
    
    // Trigger some effects
    ARCADE.delay(500, () => {
      const w = ARCADE.Renderer.getWidth(), h = ARCADE.Renderer.getHeight();
      ARCADE.Particles.burst(w/2, h/2, { count: 30, colors: ARCADE.Theme.winColors() });
      ARCADE.Camera.shake(5, 0.3);
      ARCADE.FX.flash('#22c55e', 0.2);
      ARCADE.Numbers.spawn(w/2, h/2, '+$10.00', { color: '#22c55e', glow: '#22c55e' });
      ARCADE.GlowRing.spawn(w/2, h/2, { color: '#22c55e' });
      ARCADE.EdgePulse.trigger('#22c55e', 0.5);
      ARCADE.Audio.winChime(2);
      console.log('âœ… Effects triggered');
    });
    
    // FPS display
    setInterval(() => {
      document.getElementById('fps').textContent = ARCADE.getFps() + ' FPS | ' + 
        ARCADE.Particles.getActiveCount() + ' particles | Tier: ' + ARCADE.getPerfTier();
    }, 500);
  }

  renderBg(ctx, w, h) {
    // Draw some pegs for visual
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c <= r + 3; c++) {
        const x = w/2 + (c - (r+3)/2) * 40;
        const y = 60 + r * 35;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  renderFg(ctx, w, h, alpha, dt) {
    // Animated circle
    const t = ARCADE.getStateTime() / 1000;
    const x = w/2 + Math.sin(t * 2) * 80;
    const y = h/2 + Math.cos(t * 1.5) * 60;
    
    ctx.beginPath();
    ctx.arc(x, y, 12, 0, Math.PI * 2);
    ctx.fillStyle = ARCADE.Theme.color('secondary');
    ctx.shadowColor = ARCADE.Theme.color('glow');
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Trail particles
    if (Math.random() < 0.3) {
      ARCADE.Particles.trail(x, y, { color: ARCADE.Theme.color('secondary'), size: 3 });
    }
  }

  renderUI(ctx, w, h) {
    ARCADE.Renderer.text(ctx, 'ARCADE Engine v4 â€” All Systems Nominal', w/2, 30, {
      font: 'bold 16px Inter, sans-serif',
      color: ARCADE.Theme.color('text'),
      glow: ARCADE.Theme.color('glow'),
      glowSize: 8,
    });
  }
}

// Boot
ARCADE.boot(TestGame, 'gc', {}, {
  title: 'Engine Test',
  tagline: 'All subsystems validation',
  ui_theme: {
    primary_color: '#6366f1',
    secondary_color: '#06d6a0',
    accent_color: '#8b5cf6',
    danger_color: '#ef4444',
    bg_gradient: ['#030014', '#0a0030'],
    card_bg: 'rgba(99,102,241,0.05)',
    text_color: '#e2e8f0',
    dim_color: '#94a3b8',
    glow_color: '#06d6a0',
  },
  win_particles: ['âœ¨','ğŸŒŸ','ğŸ’«','â­','ğŸš€'],
  icons: { rocket: 'ğŸš€', crash: 'ğŸ’¥', trail: 'âœ¨' },
  currency_symbol: '$',
}).then(game => {
  console.log('âœ… ARCADE.boot() complete');
  // Click to trigger effects
  document.getElementById('gc').addEventListener('click', () => {
    const w = ARCADE.Renderer.getWidth(), h = ARCADE.Renderer.getHeight();
    ARCADE.Particles.confetti(w/2, h/3, { colors: ARCADE.Theme.winColors() });
    ARCADE.Camera.shake(6, 0.3);
    ARCADE.Audio.explosion();
    ARCADE.Numbers.spawn(w/2, h/2, 'BOOM!', { color: '#f59e0b', size: 28, sizeEnd: 36 });
    ARCADE.GlowRing.spawn(w/2, h/2, { color: '#f59e0b', maxRadius: 100 });
  });
});

</script>
</body>
</html>